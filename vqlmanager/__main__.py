#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""
Denodo VQL Manager
This program shows GUI to split, select, combine and compare Denodo .vql files
Dependencies: PyQt5, qdarkstyle, (diff_match_patch in this distribution)

Author: Andre Treebus
Email: andretreebus@hotmail.com
Last edited: November 2017

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

__author__ = 'andretreebus@hotmail.com (Andre Treebus)'

# standard library
from sys import exit, argv, version_info
import logging
from pathlib import Path
from typing import Iterator, List, Tuple, Union, Sized, Tuple, Generator
import subprocess
import sys
import asyncio
from functools import partial

# other libs
from PyQt5.QtCore import Qt, QObject, QSize, QRect, QFileInfo, QTimer, QVariant, QSettings, QPoint
from PyQt5.QtGui import QIcon, QBrush, QColor
from PyQt5.QtWidgets import qApp, QApplication, QMainWindow, QWidget, QTreeWidget, QTreeWidgetItem
from PyQt5.QtWidgets import QTreeWidgetItemIterator, QMenu, QLabel, QAbstractItemView
from PyQt5.QtWidgets import QGridLayout, QSizePolicy, QHBoxLayout, QRadioButton, QButtonGroup
from PyQt5.QtWidgets import QTextEdit, QStatusBar, QAction, QMenuBar, QFileDialog, QMessageBox, QScrollArea
import qdarkstyle
from vqlmanager.diff_match_patch import *


app = None

# registry data
COMPANY = "www.erasmusmc.nl"
APPLICATION_NAME = "VQL Manager"


def message_to_user(message: str, parent=None):
    """General Messagebox functionality.
    :param message: The message to show to the user
    :type message: str
    :param parent: The owner widget of this message box
    :return: None
    :rtype: None
    """
    logger.debug('Message to user: ' + message)
    msg = QMessageBox(parent)
    msg.setWindowTitle("You got a message!")
    msg.setIcon(QMessageBox.Question)
    msg.setText("<strong>" + message + "<strong>")
    msg.setStandardButtons(QMessageBox.Ok)
    msg.setDefaultButton(QMessageBox.Ok)
    msg.exec()


def error_message_box(title: str, text: str, error: str, parent=None):
    """General messagebox if an error happened.

    :param title: Title of dialog window
    :type title: str
    :param text: Main text of dialog window
    :type text: str
    :param error: the error text generated by python
    :type error: str
    :param parent: The parent widget owning this messagebox
    :type parent: QWidget
    :return: None
    :rtype: None
    """
    logger.error(title + str(error))
    msg = QMessageBox(parent)
    msg.setWindowTitle(title)
    msg.setIcon(QMessageBox.Critical)
    msg.setText("<strong>An error has occurred!<strong>")
    msg.setInformativeText(text)
    msg.setDetailedText(error)
    msg.setStandardButtons(QMessageBox.Ok)
    msg.setDefaultButton(QMessageBox.Ok)
    msg.exec()


# setup logger
LOGGING_LEVEL = logging.DEBUG
LOGGING_FORMAT = "%(levelname)s %(asctime)s - %(message)s "
script_path = Path(__file__).parent.resolve()
log_filename = script_path / "log" / "vql_manager.log"
log_dir = log_filename.parent
if not log_dir.is_dir():
    try:
        log_dir.mkdir()
    except (OSError, IOError) as e:
        error_message_box("Log file error", "Could not create log directory: " + str(log_filename.parent), str(e))

if not log_filename.is_file():
    try:
        log_filename.touch()
    except (OSError, IOError) as e:
        error_message_box("Log file error", "Could not create logfile: " + str(log_filename), str(e))

logging.basicConfig(filename=log_filename, level=LOGGING_LEVEL, format=LOGGING_FORMAT, filemode="w")
logger = logging.getLogger("vql_manager")

# class VqlConstants(QObject):
# convenience names for class constants
# checkbox option in the tree widgets
PART_STATE = Qt.PartiallyChecked
CHECKED = Qt.Checked
UNCHECKED = Qt.Unchecked

# Hint for the width of the tree widgets
PANE_WIDTH = 300

# # application modes en flags

# colors used
red = "#ff4444"
green = "#44ff44"
yellow = "#ffff44"
white = "#cccccc"

RED = QBrush(QColor(red))
GREEN = QBrush(QColor(green))
YELLOW = QBrush(QColor(yellow))
WHITE = QBrush(QColor(white))

# item flags for the all_chapters and selection tree widget items
ITEM_FLAG_ALL = Qt.ItemIsEnabled
ITEM_FLAG_CHAPTER = Qt.ItemIsEnabled | Qt.ItemIsUserCheckable | Qt.ItemIsTristate
ITEM_FLAG_CODE_ITEM = Qt.ItemIsEnabled | Qt.ItemIsUserCheckable
ITEM_FLAG_SEL = Qt.ItemIsSelectable | Qt.ItemIsEnabled


LOG_FILE_NAME = "part.log"

# main chapter names as used in Denodo code
CHAPTER_NAMES = ["I18N MAPS", "DATABASE", "FOLDERS", "LISTENERS JMS", "DATASOURCES", "WRAPPERS",
                 "STORED PROCEDURES", "TYPES", "MAPS", "BASE VIEWS", "VIEWS", "ASSOCIATIONS",
                 "WEBSERVICES", "WIDGETS", "WEBCONTAINER WEB SERVICE DEPLOYMENTS",
                 "WEBCONTAINER WIDGET DEPLOYMENTS"]

# the delimiter use to separate chapters into CodeItems
DELIMITER = "CREATE OR REPLACE"

# Start quote of the Denodo script
PROP_QUOTE = "# REQUIRES-PROPERTIES-FILE - # Do not remove this comment!\n#\n"


# app_state flags
class GuiType(QObject):
    """
    Global constants for the gui modes
    """
    GUI_NONE = 1 << 1                  # initial or reset mode
    GUI_SELECT = 1 << 2           # gui set to selection mode
    GUI_COMPARE = 1 << 3          # gui set to compare, with a base model and a compare model


class ModelState(QObject):
    """
    Global constants for the gui modes
    """
    BASE_FILE = 1 << 4        # indicate that the base model is a single file
    BASE_REPO = 1 << 5        # indicate that the base model is a repository (folder structure)
    COMP_FILE = 1 << 6        # indicate that the base model is a single file
    COMP_REPO = 1 << 7        # indicate that the base model is a repository (folder structure)
    BASE_LOADED = 1 << 8      # indicate that the base model is loaded
    COMP_LOADED = 1 << 9      # indicate that the compare model is loaded


class SourceType(QObject):
    """
    Global constants for the gui modes
    """
    FILE = ModelState.BASE_FILE | ModelState.COMP_FILE
    REPO = ModelState.BASE_REPO | ModelState.COMP_REPO


class ViewType(QObject):
    """
    Global constants for the gui modes
    """
    VQL_VIEW = 1 << 12
    DENODO_VIEW = 1 << 13


class CodeView(QObject):
    """
    Global constants for the gui modes
    """
    ORIGINAL_CODE = 1 << 14
    COMPARE_CODE = 1 << 15
    DIFF_CODE = 1 << 16


# Q_FLAGS(GuiType)
# Q_FLAGS(ModelState)
# Q_FLAGS(SourceType)
# Q_FLAGS(ViewType)
# Q_FLAGS(CodeView)

GUI_NONE = GuiType.GUI_NONE
GUI_SELECT = GuiType.GUI_SELECT
GUI_COMPARE = GuiType.GUI_COMPARE

BASE_FILE = ModelState.BASE_FILE
BASE_REPO = ModelState.BASE_REPO
COMP_FILE = ModelState.COMP_FILE
COMP_REPO = ModelState.COMP_REPO
BASE_LOADED = ModelState.BASE_LOADED
COMP_LOADED = ModelState.COMP_LOADED

FILE = SourceType.FILE
REPO = SourceType.REPO

VQL_VIEW = ViewType.VQL_VIEW
DENODO_VIEW = ViewType.DENODO_VIEW

ORIGINAL_CODE = CodeView.ORIGINAL_CODE
COMPARE_CODE = CodeView.COMPARE_CODE
DIFF_CODE = CodeView.DIFF_CODE


def translate_colors(item_color: Union[str, QBrush], to_text=True)->Union[str, QBrush]:
    """
    Function for translating item QBrush objects for strings
    This is needed because the set function does not accept unhashable items
    :param item_color: the object to be translated
    :type item_color: str or QBrush
    :param to_text: indicator for the direction of the tranlation
    :type to_text: bool
    :return: Translated value
    :rtype: QBrush or str
    """
    color = None
    if to_text:
        if item_color == RED:
            color = red
        elif item_color == GREEN:
            color = green
        elif item_color == YELLOW:
            color = yellow
        elif item_color == WHITE:
            color = white
    else:
        if item_color == red:
            color = RED
        elif item_color == green:
            color = GREEN
        elif item_color == yellow:
            color = YELLOW
        elif item_color == white:
            color = WHITE
    return color


def show_mode(mode: int)->str:
    """Returns debug info string to logger.

    :param mode: the mode to show
    :type mode: int
    :return: a human readable string with flags
    :rtype: str
    """
    gui_types = {GUI_NONE: "GUI_NONE", GUI_SELECT: "GUI_SELECT", GUI_COMPARE: "GUI_COMPARE"}
    model_states = {BASE_FILE: "BASE_FILE", BASE_REPO: "BASE_REPO", COMP_FILE: "COMP_FILE", COMP_REPO: "COMP_REPO",
                    BASE_LOADED: "BASE_LOADED", COMP_LOADED: "COMP_LOADED"}
    source_types = {FILE: "FILE", REPO: "REPO"}

    mode_txt = list()

    for num, name in gui_types.items():
        if mode & num:
            mode_txt.append(name)

    for num, name in model_states.items():
        if mode & num:
            mode_txt.append(name)

    for num, name in source_types.items():
        if mode & num:
            mode_txt.append(name)

    return " : ".join(mode_txt)


def get_reserved_words()->Iterator[Sized]:
    """Returns a list (Iterator) over the Denodo reserved words.

    :return: the list as Iterator
    :rtype: Iterator[Sized]
    """
    words = ["ADD", "AS", "ANY", "OPT", "OR", "CREATE", "VIEW", "NULL", "ALTER", "NOT", "FROM", "AND", "SELECT",
             "WHEN", "JOIN", "IS", "ON", "LEFT", "CASE", "TABLE", "WHERE", "DEFAULT", "OFF", "JDBC", "INNER", "OF",
             "ZERO", "NOS", "UNION", "DF", "DISTINCT", "ASC", "FULL", "FALSE", "DESC", "BASE", "DATABASE", "TRUE",
             "ALL", "CONTEXT", "CONNECT", "LDAP", "WITH", "SWAP", "ARN", "BOTH", "CALL", "CROSS", "CURRENT_DATE",
             "CURRENT_TIMESTAMP", "CUSTOM", "DROP", "EXISTS", "FETCH", "FLATTEN", "GRANT", "GROUP BY", "GS", "HASH",
             "HAVING", "HTML", "IF", "INTERSECT", "INTO", "LEADING", "LIMIT", "MERGE", "MINUS", "MY", "NATURAL",
             "NESTED", "OBL", "ODBC", "OFFSET", "ONE", "ORDER BY", "ORDERED", "PRIVILEGES", "READ", "REVERSEORDER",
             "REVOKE", "RIGHT", "ROW", "TO", "TRACE", "TRAILING", "USER", "USING", "WRITE", "WS"]

    words.append(DELIMITER)
    words.extend(CHAPTER_NAMES)
    reserved_words = reversed(sorted(words, key=len))
    return reserved_words


RECENT_FILES = "recent_file_list"
RECENT_REPOSITORIES = "recent_repositories_list"
MAX_RECENT_FILES = 8

# <link rel="stylesheet" type="text/css" href="mystyle.css">


def doc_template(object_name: str, body: str)->str:
    """
    Returns a html page
    :param object_name: name of the object
    :param body: body of the page
    :return: the page
    """
    doc = """
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>""" + object_name + """</title>
    <meta name="description" content="Denodo code part">
  </head>
  <body>""" + body + """</body>
</html>
"""
    return doc


about_text = """
VQL Manager was created by Erasmus MC Rotterdam The Netherlands 2017.
This application is open source software.
Questions and remarks should be sent to: andretreebus@hotmail.com
"""

diff_engine = diff_match_patch()
diff_engine.Diff_Timeout = 2
diff_engine.Match_Threshold = 0.0
diff_engine.Patch_DeleteThreshold = 0.0
diff_engine.Match_MaxBits = 0


class CodeItem(QTreeWidgetItem):
    """CodeItem class represents a .vql file with a single Denodo object.

    It inherits from QTreeWidgetItem, so it can display in a QTreeWidget.
    Basically a bag for pieces of Denodo code.
    """
    def __init__(self, parent: QTreeWidgetItem, chapter_name: str, mode: int,
                 code=None, compare_code=None, preceding=None):
        """CodeItem Class constructor.

        :param parent: The object owning this object
        :type parent: Chapter
        :param chapter_name: the chapter name
        :type chapter_name: str
        :param mode: the mode flag
        :type mode: int
        :param code: optional: the code related to this denodo object
        ::type code: str
        :param code: optional: the other code related to this denodo object for comparisons
        ::type code: str
        :param preceding: the CodeItem after which this code item is placed in the tree
        :type preceding: CodeItem
        """

        if preceding:
            super(CodeItem, self).__init__(parent, preceding, 0)
        else:
            super(CodeItem, self).__init__(parent)
        self.user_data = dict()
        self.setCheckState(0, CHECKED)
        self.childIndicatorPolicy = 2
        self.setFlags(ITEM_FLAG_CODE_ITEM)  # from parent
        self.class_type = CodeItem
        self.chapter_name = chapter_name
        self.mode = mode
        self.code = code
        self.compare_code = compare_code
        self.object_name = ''
        self.denodo_folder = ''
        self.color = WHITE
        self.set_color(WHITE)
        self.gui = GUI_SELECT
        self.dependencies = list()
        self.dependees = list()
        self.compare_dependencies = list()
        self.compare_dependees = list()

        if code:
            self.object_name = self.extract_object_name_from_code(self.chapter_name, self.code)
            self.denodo_folder = self.extract_denodo_folder_name_from_code(self.chapter_name, self.code)

        if compare_code:
            self.object_name = self.extract_object_name_from_code(self.chapter_name, self.compare_code)
            self.denodo_folder = self.extract_denodo_folder_name_from_code(self.chapter_name, self.compare_code)
            self.set_compare_code(compare_code, mode)

        if self.object_name:
            self.setText(0, self.object_name)

        if mode & (COMP_FILE | COMP_REPO):
            self.compare()
        self.pack(WHITE)
        logger.debug(f">>>> CodeItem: {self.object_name if self.object_name else '_'} created.")

    def set_compare_code(self, compare_code: str, mode: int):
        """Setter for the compare mode and code.

        :param compare_code: the other code
        :type compare_code: str
        :param mode: new mode
        :type mode: int
        :return: None
        :rtype: None
        """
        self.mode |= mode
        self.compare_code = compare_code
        self.compare()

    def compare(self):
        """Compare the code and sets color to the item itself.

        White = unchanged; Red = lost; Green = new; Yellow = changed
        :return: None
        :rtype: None
        """
        if self.code:
            if self.compare_code:
                if self.compare_code == self.code:
                    self.set_color(WHITE)
                else:
                    self.set_color(YELLOW)
            else:
                if self.mode & GUI_COMPARE:
                    self.set_color(RED)
                else:
                    self.set_color(RED) if self.dependees else self.set_color(WHITE)
        else:
            if self.compare_code:
                self.set_color(GREEN)
            else:
                # code item with identity crisis
                self.suicide()

    @staticmethod
    def get_diff(code: str, compare_code: str)->str:
        """Supplies the code edit widget with html for the comparison.

        The main intel of this function is supplied by the global instance of the diff_match_patch.py engine
        maintained on Google. Here the engine is used on the two code pieces and a patch is calculated
        the patch is again inserted in the prettyHtml function of the engine and modded a bit
        The colors are similar to the usage in this tool
        to get new code (compare_code) from old code (code), remove red, add green

        :param code: the original code
        :type code: str
        :param compare_code: the new code
        :type compare_code: str
        :return: html representation of teh difference
        :rtype: str
        """
        def format_code(_code: str)->str:
            """
            Formats a code piece as html
            :param _code: The code to be formatted
            :return: the html of the code
            :rtype: str
            """
            _code = _code.replace('<br>', '<br />\n')
            _code = _code.replace('&para;', '')
            _code = _code.replace('    ', ' &nbsp; &nbsp; &nbsp; &nbsp; ')
            return _code

        def format_code2(_code: str)->str:
            """
            Formats a code piece as html
            :param _code: The code to be formatted
            :return: the html of the code
            :rtype: str
            """
            _code = _code.replace('\n', '<br />\n')
            _code = _code.replace('    ', ' &nbsp; &nbsp; &nbsp; &nbsp; ')
            return _code

        def set_green(_code: str)->str:
            """
            Formats a code piece as html to set it green
            :param _code: The code to be formatted
            :return: the html of the code
            :rtype: str
            """
            return '<span>' + new_diff_ins_indicator + _code + '</ins></span>'

        def set_red(_code: str)->str:
            """
            Formats a code piece as html to set it red
            :param _code: The code to be formatted
            :return: the html of the code
            :rtype: str
            """
            return '<span>' + new_diff_del_indicator + _code + '</del></span>'

        diff_ins_indicator = '<ins style="background:#e6ffe6;">'
        diff_del_indicator = '<del style="background:#ffe6e6;">'
        new_diff_ins_indicator = '<ins style="color:' + green + ';">'
        new_diff_del_indicator = '<del style="color:' + red + ';">'
        diff_html = ''
        if code:
            if compare_code:
                diff_patch = diff_engine.diff_main(code, compare_code)
                diff_html = format_code(diff_engine.diff_prettyHtml(diff_patch))
                diff_html = diff_html.replace(diff_ins_indicator, new_diff_ins_indicator)
                diff_html = diff_html.replace(diff_del_indicator, new_diff_del_indicator)
            else:
                diff_html = format_code2(set_red(code))
        else:
            if compare_code:
                diff_html = format_code2(set_green(compare_code))

        return diff_html

    def pack(self, color_filter: QBrush):
        """Packs and filters this code item object.

        Used before it gets cloned.
        The clone function only supports QTreeWidgetItem data,
        so we survive in the standard data(Qt.UserRole) in a dictionary.

        :param color_filter: The color that is selected
        :type color_filter: QBrush
        :return: None
        :rtype: None
        """
        if color_filter:
            if not self.color == color_filter:
                self.setHidden(True)
            else:
                self.setHidden(False)
        else:
            self.setHidden(False)

        self.user_data['chapter_name'] = self.chapter_name
        self.user_data['object_name'] = self.object_name
        self.user_data['code'] = self.code
        self.user_data['compare_code'] = self.compare_code
        self.user_data['color'] = self.color
        self.user_data['denodo_folder'] = self.denodo_folder
        self.user_data['gui'] = self.gui
        self.user_data['class_type'] = self.class_type
        self.user_data['selected'] = self.is_selected()
        self.user_data['hidden'] = self.isHidden()
        self.setData(0, Qt.UserRole, self.user_data)

    @staticmethod
    def unpack(item: QTreeWidgetItem):
        """Unpacks and filters this code item.

        Used after it has been cloned and packed.
        The clone function only supports QTreeWidgetItem data,
        so we survive in the standard data member data.(Qt.UserRole)
        in a dictionary. This is a static member to unpack
        the resulting QTreeWidgetItem after cloning.

        :param item: item to be unpacked
        :type item: QTreeWidgetItem
        :return: None
        :rtype: None
        """

        item.user_data = item.data(0, Qt.UserRole)
        item.chapter_name = item.user_data['chapter_name']
        item.object_name = item.user_data['object_name']
        item.code = item.user_data['code']
        item.compare_code = item.user_data['compare_code']
        item.color = item.user_data['color']
        item.denodo_folder = item.user_data['denodo_folder']
        item.gui = item.user_data['gui']
        item.class_type = item.user_data['class_type']
        item.is_selected = item.user_data['selected']
        item.setHidden(item.user_data['hidden'])

    def set_gui(self, gui: int):
        """Sets the gui type flag.

        This function also resets the compare mode if it was there.

        :param gui: mode flag
        :type gui: int
        :return: None
        :rtype: None
        """

        self.gui = gui
        if gui == GUI_SELECT:
            if self.mode & COMP_REPO:
                self.mode -= COMP_REPO
            if self.mode & COMP_FILE:
                self.mode -= COMP_FILE
            self.set_compare_code('', self.mode | GUI_SELECT)

    def suicide(self):
        """Asks dad to shoot you.

        Item gets pruned from the tree.
        :return: None
        :rtype: None
        """
        self.parent().remove_child(self)

    def get_file_path(self, folder: Path)->Path:
        """Get the file path for this code item.

        This function changes and slash, forward and backward into an underscore
        Warning: this can potentially be dangerous if two uniquely named objects
         turn out to have the same name after turning slashes to underscores.

        :param folder: the folder in which code item resides
        :type folder: Path
        :return: Path
        """

        file_name = folder / (self.object_name.replace('/', '_').replace('\\', '_') + '.vql')
        return file_name

    def is_selected(self)->bool:
        """Is the object selected.

        :return: Boolean
        :rtype: bool
        """
        if self.checkState(0) == CHECKED:
            return True
        else:
            return False

    def set_color(self, color: QBrush):
        """Set the color.

        :param color:
        :type color: QBrush
        :return: None
        :rtype: None
        """

        self.color = color
        self.setForeground(0, color)

    def remove_compare(self):
        """Function reverts the loading of compare code.

        :return: None
        :rtype: None
        """

        if self.compare_code:
            if not self.code:
                self.suicide()
        if self.code:
            self.set_gui(GUI_SELECT)
            self.set_color(WHITE) if self.dependees else self.set_color(RED)
            if self.compare_code:
                self.denodo_folder = self.extract_denodo_folder_name_from_code(self.chapter_name, self.code)

    @staticmethod
    def extract_denodo_folder_name_from_code(chapter_name: str, code: str)->Union[Path, None]:
        """Extracts the denodo folder name from code.

        :param chapter_name: Type of denodo object
        :type chapter_name: str
        :param code: the code to create the object
        :type code: str
        :return: The denodo path
        :rtype: Union[Path, None]
        """
        if chapter_name == 'DATASOURCES' and code.find('DATASOURCE LDAP') > -1:
                folder_path = ''
        elif chapter_name in ['I18N MAPS', 'DATABASE', 'DATABASE CONFIGURATION', 'TYPES']:
            folder_path = ''
        elif chapter_name == 'FOLDERS':
            start = code.find('\'') + 2
            end = len(code) - 5
            folder_path = code[start:end]
        else:
            start = code.find('FOLDER = \'') + 11
            end = code.find('\'', start)
            folder_path = code[start:end]

        if folder_path:
            folder_path = Path(folder_path.lower())
        else:
            folder_path = None
        return folder_path

    @staticmethod
    def extract_object_name_from_code(chapter_name: str, code: str)->str:
        """Searches for the Denodo object name.

        Helper function for the 'parse' function
        The function constructs a unique object name in its code
        Each chapter has its own way of extracting the object name

        Warning: With newer versions of Denodo it should be checked if the structure they use is the same

        :param chapter_name: string with the name of the chapter it belongs to
        :type chapter_name: str
        :param code: string with code relating to one object in Denodo
        :type code: str
        :return: string with the filename
        :rtype: str
        """

        def get_last_word(line):
            """
            Helper function for the extract_filename function
            :param line: string, one line of code (the first line)
            :type line: str
            :return: string with the last word on the line
            :rtype: str
            """
            line_reversed = line.strip()[::-1]
            last_space = line_reversed.find(' ')
            last_word = line_reversed[0:last_space][::-1]
            return last_word.strip()

        object_name = ''

        # Object names are on the first line of the code item
        first_line = code[0:code.find("\n")]

        if chapter_name == 'I18N MAPS':
            object_name = get_last_word(first_line[0:-2])
        elif chapter_name == 'DATABASE':
            object_name = first_line.split()[4]
        elif chapter_name == 'FOLDERS':
            object_name = first_line[27:-3]
        elif chapter_name == 'LISTENERS JMS':
            pass  # Todo: we don't use these kind of objects in Denodo
        elif chapter_name == 'DATASOURCES':
            object_name = get_last_word(first_line)
        elif chapter_name == 'WRAPPERS':
            object_name = get_last_word(first_line)
        elif chapter_name == 'STORED PROCEDURES':
            pass  # Todo: we don't use these kind of objects in Denodo
        elif chapter_name == 'TYPES':
            object_name = first_line.split()[4]
        elif chapter_name == 'MAPS':
            pass  # Todo: we don't use these kind of objects in Denodo
        elif chapter_name == 'BASE VIEWS':
            object_name = first_line.split()[4]
        elif chapter_name == 'VIEWS':
            split = first_line.split(' ')
            if split[3] == 'INTERFACE':
                object_name = split[5]
            else:
                object_name = split[4]
        elif chapter_name == 'ASSOCIATIONS':
            object_name = first_line.split()[4]
        elif chapter_name == 'WEBSERVICES':
            pass  # Todo: we don't use these kind of objects in Denodo
        elif chapter_name == 'WIDGETS':
            pass  # Todo: we don't use these kind of objects in Denodo
        elif chapter_name == 'WEBCONTAINER WEB SERVICE DEPLOYMENTS':
            pass  # Todo: we don't use these kind of objects in Denodo
        elif chapter_name == 'WEBCONTAINER WIDGET DEPLOYMENTS':
            pass  # Todo: we don't use these kind of objects in Denodo

        return object_name


class Chapter(QTreeWidgetItem):
    """Chapter class represents a group of Denodo objects of the same kind.

    For example: a BASEVIEW or a ASSOCIATION etc.
    The Chapter class also represents a folder in the repository.
    The Chapter class is the owner/parent of the CodeItems.
    It inherits from QTreeWidgetItem, so it can display in a QTreeWidget.
    """

    def __init__(self, parent: Union[QTreeWidget, None], name: str):
        """Initializer of the class objects

        :param parent: reference to the parent or owner, this should be a VqlModel class (QTreeWidget)
        :type parent: VqlModel
        :param name: string name of the chapter
        :type name: str
        """

        super(Chapter, self).__init__(parent)
        self.user_data = dict()
        self.setCheckState(0, CHECKED)
        self.childIndicatorPolicy = 2
        self.setFlags(ITEM_FLAG_CHAPTER)
        self.class_type = Chapter
        self.name = name
        self.setText(0, name)
        self.header = self.make_header(name)
        self.code_items = list()
        self.chapter_items = list()
        self.parent_chapter_name = ''
        self.color = None
        self.set_color(WHITE)
        self.gui = GUI_SELECT
        self.pack(WHITE)
        logger.debug(f">> Chapter: {self.name} created.")

    # General functions

    def pack(self, color_filter: QBrush):
        """Packs and filters this chapter object and its code_item children.

        Used before it gets cloned.
        The clone function only supports QTreeWidgetItem data,
        so we survive in the standard data(Qt.UserRole) in a dictionary.

        :param color_filter: The color that is selected
        :type color_filter: QBrush
        :return: None
        :rtype: None
        """

        self.user_data['name'] = self.name
        self.user_data['header'] = self.header
        self.user_data['code_items'] = self.code_items
        self.user_data['chapter_items'] = self.chapter_items
        self.user_data['parent_chapter_name'] = self.parent_chapter_name
        self.user_data['color'] = self.color
        self.user_data['gui'] = self.gui
        self.user_data['class_type'] = self.class_type
        self.user_data['selected'] = self.is_selected()
        self.user_data['expanded'] = self.isExpanded()
        for code_item in self.code_items:
            code_item.chapter_name = self.name
            code_item.pack(color_filter)
        for chapter in self.chapter_items:
            chapter.parent_chapter_name = self.name
            chapter.pack(color_filter)
        self.set_color_based_on_children(self.gui)
        self.setData(0, Qt.UserRole, self.user_data)

    @staticmethod
    def unpack(item: QTreeWidgetItem):
        """Unpacks and filters this chapter object and its code_item children.

        Used after it has been cloned and packed,
        The clone function only supports QTreeWidgetItem data,
        so we survive in the standard data member data.(Qt.UserRole)
        in a dictionary
        This is a static member to unpack the resulting QTreeWidgetItem after cloning

        :param item: item to be unpacked
        :type item: QTreeWidgetItem
        :return: None
        :rtype: None
        """

        item.user_data = item.data(0, Qt.UserRole)
        item.name = item.user_data['name']
        item.header = item.user_data['header']
        item.code_items = item.user_data['code_items']
        item.color = item.user_data['color']
        item.chapter_items = item.user_data['chapter_items']
        item.gui = item.user_data['gui']
        item.class_type = item.user_data['class_type']
        item.is_selected = item.user_data['selected']
        item.setExpanded(item.user_data['expanded'])
        deletes = list()
        for i in range(item.childCount()):
            child = item.child(i)
            if child.checkState(0) == UNCHECKED:
                deletes.append(child)
        for child in reversed(deletes):
            item.takeChild(item.indexOfChild(child))

        deletes = list()
        for i in range(item.childCount()):
            child = item.child(i)
            item_class = child.data(0, Qt.UserRole)['class_type']
            if child.childCount() == 0 and not item_class == CodeItem:
                deletes.append(child)
        for child in reversed(deletes):
            item.takeChild(item.indexOfChild(child))

        for i in range(item.childCount()):
            child = item.child(i)
            item_class = child.data(0, Qt.UserRole)['class_type']
            item_class.unpack(child)

    @staticmethod
    def make_header(chapter_name: str)->str:
        """Constructs a string that can be used to identify chapters in a Denodo exported database file.

        :param chapter_name: string with Chapter name
        :type chapter_name: str
        :return: The chapter Header
        :rtype: str
        """
        chapter_header = '# #######################################\n# ' \
                         + chapter_name + '\n# #######################################\n'
        return chapter_header

    def set_gui(self, gui: int):
        """Sets the Gui type (GUI_SELECT GUI_COMPARE) on the chapter and its children.

        :param gui: the new GUI type
        :type gui: int
        :return:None
        :rtype: None
        """
        self.gui = gui
        for chapter in self.chapter_items:
            chapter.set_gui(gui)
        for code_item in self.code_items:
            code_item.set_gui(gui)

    def set_color_based_on_children(self, mode: int, color=None):
        """Sets the color of chapters based on the non hidden children.

        :param mode: the mode of the gui
        :type mode: int
        :param color: Optional parameter to set the color only
        :type color: QBrush
        :return: None
        :rtype: None
        """
        if color:
            self.set_color(color)
            return

        colors = [translate_colors(code_item.color, to_text=True)
                  for code_item in self.code_items if not code_item.isHidden()]
        colors.extend([translate_colors(chapter_item.color, to_text=True)
                       for chapter_item in self.chapter_items if not chapter_item.isHidden()])
        unique_colors = list(set(colors))
        length = len(unique_colors)
        if length == 0:
            if mode & GUI_SELECT:
                self.set_color(WHITE)
            else:
                self.set_color(RED)
        elif length == 1:
            self.set_color(translate_colors(unique_colors[0], to_text=False))
        else:
            self.set_color(YELLOW)

    def set_color(self, color: QBrush):
        """Set the color of this item.

        :param color:
        :type color: QBrush
        :return:
        """
        self.color = color
        self.setForeground(0, color)

    def get_code_item_by_object_name(self, object_name: str)->Tuple[int, Union[CodeItem, None]]:
        """Returns a tuple of a code item child and the index it has.

        :param object_name: The object name of the CodeItem
        :type object_name: str
        :return: The tuple of index and code item object itself
        :rtype: tuple(int, CodeItem)
        """
        if object_name:
            for index, code_item in enumerate(self.code_items):
                if code_item:
                    if code_item.object_name == object_name:
                        return index, code_item
        return 0, None

    def is_selected(self)->bool:
        """Function returns if the chapter is selected or has some code items selected (tri state).

        :return: Boolean
        :rtype: bool
        """
        if self.checkState(0) in (PART_STATE, CHECKED) and len(self.code_items) > 0:
            return True
        else:
            return False

    # export functions
    # to file
    def get_code_as_file(self, mode: int, selected: bool)->str:
        """Returns the combined Denodo code for a whole chapter.

        This function adds a chapter header, and only selected code items
        :param mode: either GUI_SELECT or GUI_COMPARE ; what code to return
        :type mode: int
        :param selected: Indicator is True if only selected items are requested
        :type selected: bool
        :return: string with code content
        :rtype: str
        """
        code = []
        if selected and self.is_selected():
            if mode & GUI_SELECT:
                code = [code_item.code for code_item in self.code_items if code_item.is_selected()]
            elif mode & GUI_COMPARE:
                code = [code_item.compare_code for code_item in self.code_items if code_item.is_selected()]
        else:
            if mode & GUI_SELECT:
                code = [code_item.code for code_item in self.code_items]
            elif mode & GUI_COMPARE:
                code = [code_item.compare_code for code_item in self.code_items]
        return self.header + '\n'.join(code)

    # to repository
    def get_part_log(self, base_path: Path)->Tuple[Path, str]:
        """Returns data to write the part.log files.

        Returning two values: the file path for the part.log file and its content as a string.
        The content is a list of file paths pointing to the code items in this chapter.
        The part.log files are used in a repository to ensure the same order of execution.
        Only the selected code items are included.
        :param base_path: The base folder for the repo
        :type base_path:  Path
        :return: Two values, a file path and the content of the part.log file of this chapter
        :rtype: tuple Path, str
        """
        folder = base_path / self.name
        part_log_filepath = folder / LOG_FILE_NAME
        part_log = [str(code_item.get_file_path(folder)) for code_item in self.code_items if code_item.is_selected()]
        part_log_content = '\n'.join(part_log)
        return part_log_filepath, part_log_content

    def selected_items(self)->List[CodeItem]:
        """Function for looping over selected code items.

        :return: list with items
        :rtype: list(CodeItem)
        """
        items = [code_item for code_item in self.code_items if code_item.is_selected()]
        return items


class VqlModel(QTreeWidget):
    """VqlModel class represents all objects in a Denodo database.

    The VqlModel class also represents a Repository file structure.
    The Chapter class is the owner/parent of the Chapter instances.
    It inherits from QTreeWidget, so it can display in a QMainWindow or QWidget.
    In this application it is instanced as: all_chapter_treeview.
    The purpose of this class is to make GUI based selections.
    """

    def __init__(self, parent: Union[QWidget, None]):
        """Constructor of the class.

        Mostly setting the stage for the behavior of the QTreeWidget.

        :param parent: the object holding this instance, a central widget of the QMainWindow
        :type parent: QWidget
        """
        super(VqlModel, self).__init__(parent)

        # custom class variables #########################
        # root is the first/parent node for all QTreeWidgetItem children
        self.root = self.invisibleRootItem()

        # chapters are stored in a list of Chapters inherited from QTreeWidgetItem
        self.chapters = list()

        # initialize by adding empty chapters
        self._add_chapters(CHAPTER_NAMES)
        # changed is a boolean indicating a change in selection was made
        self.changed = False
        # mode of operation: see mode variable flags in vql_manager_core
        self.mode = GUI_NONE
        # storage_list to store items for different views
        self.storage_list = list()
        # view stores the current view
        self.view = VQL_VIEW
        # denodo_root is a reference to the root item of the denodo view
        self.denodo_root = Chapter(None, 'root')
        # color_filter used to filter items
        self.color_filter = None

    def pack(self):
        """Packs all data of the tree into UserData of the QTreeWidgetItems.

        :return: None
        :rtype: None
        """
        for chapter in self.chapters:
            chapter.pack(self.color_filter)

    @staticmethod
    def unpack(tree: QTreeWidget):
        """Unpacks the data from QtreeWidgetItem's Userdata.

        It also prunes the tree on checked items only with children
        :param tree: The QtreeWidget to work on
        :type tree: QtreeWidget
        :return: None
        :rtype: None
        """
        deletes = list()
        for i in range(tree.topLevelItemCount()):
            child = tree.topLevelItem(i)
            if (child.childCount() == 0) or (child.checkState(0) == UNCHECKED):
                deletes.append(child)
            else:
                item_class = child.data(0, Qt.UserRole)['class_type']
                item_class.unpack(child)
        for child in reversed(deletes):
            tree.takeTopLevelItem(tree.indexOfTopLevelItem(child))

    def _add_chapters(self, chapter_names: List[str]):
        """Method that adds a chapter to the chapter list for every name given.

        :param chapter_names: list of chapter_names of type string
        :type chapter_names: list
        :return: None
        :rtype: None
        """
        for chapter_name in chapter_names:
            chapter = Chapter(self.root, chapter_name)
            self.chapters.append(chapter)

    def get_code_items(self, chapter_list=None)->Tuple[Chapter, CodeItem]:
        """Generator to loop all code items.

        Optionally a list with chapter names may be given as a filter.
        Only chapter names in the lis are then included.

        :param chapter_list: Optional list with chapter names
        :type chapter_list: list
        :return: Yields a tuple of chapter and code_item
        :rtype: Tuple[Chapter, CodeItem]
        """
        if chapter_list:
            chapters = (chapter for chapter in self.chapters if chapter.name in chapter_list)
        else:
            chapters = (chapter for chapter in self.chapters)

        for chapter in chapters:
            for code_item in chapter.code_items:
                yield (chapter, code_item)

    def get_code_as_file(self, mode: int, selected: bool)->str:
        """Function that puts the code content in a single .vql file of all checked/selected items.
        :param mode: GUI indicator saving either compare code or base code GUI_SELECT or GUI_COMPARE
        :type mode: int
        :param selected: Only selected items or not
        :type selected: bool
        :return: string of code content
        :rtype: str
        """

        code = [chapter.get_code_as_file(mode, selected) for chapter in self.chapters]
        return PROP_QUOTE + '\n'.join(code)

    def get_part_logs(self, folder: Path):
        """Gives all part.log data.

        With log file names (key) and their content (values).
        The content is a list of paths to the code items in a chapter.
        This function is used to create a repository.
        :param folder: The folder to save the repo to
        :type folder: Path
        :return: Iterator with filepaths and content
        :rtype: generator of tuples: part_log_filepath, part_log_content
        """
        result = (chapter.get_part_log(folder) for chapter in self.chapters if chapter.is_selected())
        return result

    def get_selected_code_files(self, mode: int, folder: Path)->List[Tuple[Path, str]]:
        """Function for looping over all selected code items in the model.

        This function is used to write the repository
        :param mode: the mode to select which code; either GUI_SELECT or GUI_COMPARE
        :type mode: int
        :param folder: the proposed folder for storage
        :type folder: Path
        :return: an iterator with two unpacked values: filepath and code content
        :rtype: list(tuple(Path, str))
        """

        item_path_code = list()
        for chapter in self.chapters:
            items = chapter.selected_items()
            chapter_folder = folder / chapter.name
            for code_item in items:
                item_path = code_item.get_file_path(chapter_folder)
                if mode & GUI_SELECT:
                    item_code = code_item.code
                elif mode & GUI_COMPARE:
                    item_code = code_item.compare_code
                else:
                    item_code = ''
                item_path_code.append((item_path, item_code))
        return item_path_code

    def get_chapter_by_name(self, chapter_name: str)->Chapter:
        """Function that returns a chapter from the 'chapters' list by its name.

        :param chapter_name: the name of the particular chapter requested
        :type chapter_name: str
        :return: A single chapter
        :rtype: Chapter
        """
        chapter = None
        for chapter in self.chapters:
            if chapter.name == chapter_name:
                break
        return chapter

    def switch_mode(self, new_mode: int):
        """Method to switch mode on the tree item, sets appropriate headers and tooltips.

        :param new_mode: The new mode
        :type new_mode: int
        :return: None
        """

        if new_mode & GUI_NONE:
            self.setHeaderLabel('')
            self.setToolTip('No model loaded, Open a file or repository')
        if new_mode & GUI_SELECT:
            self.setHeaderLabel('Selection Pane')
            self.setToolTip('Check the parts you like to select')
        elif new_mode & GUI_COMPARE:
            self.setHeaderLabel('Compare Pane')
            self.setToolTip('Select items')
            self.setToolTipDuration(1000)

    async def parse(self, file_content: str, mode: int):
        """Method that parses the denodo export file.

        It analyzes it to construct/fill the VqlModel tree.

        :param file_content: String with the denodo file
        :type file_content: str
        :param mode: the application mode, selecting or comparing
        :param mode: int
        :return: None
        :rtype: None
        """
        logger.debug('Start parsing data.')
        self.changed = False
        gui = GUI_NONE

        if mode & (BASE_FILE | BASE_REPO):
            gui = GUI_SELECT
        elif mode & (COMP_FILE | COMP_REPO):
            gui = GUI_COMPARE
            # set all items to red, indicating they are lost.. this will later change if not
            for _, code_item in self.get_code_items():
                code_item.set_compare_code('', mode)

        # remove possible crab above first chapter
        for chapter in self.chapters:
            start_index = file_content.find(chapter.header)
            if not start_index == -1:
                file_content = file_content[start_index:]
                break

        # construct a list with indices where chapters start
        indices = list()
        for chapter in self.chapters:
            start_string_index = file_content.find(chapter.header)
            if start_string_index == -1:
                continue
            indices.append((chapter, start_string_index))
        indices.append(('', len(file_content)))

        # extract data from the file
        # zip the indices shifted one item to get start and end of the chapter code
        for start_tuple, end_tuple in zip(indices[:-1], indices[1:]):
            index = 0
            chapter, start = start_tuple
            next_chapter, end = end_tuple
            if start == -1:
                continue
            chapter_part = file_content[start:end]   # << contains chapter code
            chapter_objects = chapter_part.split(DELIMITER)[1:]  # split on CREATE OR REPLACE
            for chapter_object in chapter_objects:
                code = DELIMITER + chapter_object  # << put back the delimiter
                object_name = CodeItem.extract_object_name_from_code(chapter.name, code)  # extract object name
                if not object_name:
                    continue
                if gui == GUI_SELECT:
                    # add the code item to the chapter
                    chapter.code_items.append(CodeItem(chapter, chapter.name, mode, code=code))

                elif mode & (COMP_FILE | COMP_REPO):   # COMPARE case
                    # Check if item exists, and where
                    i, existing_item = chapter.get_code_item_by_object_name(object_name)
                    if existing_item:
                        existing_item.set_compare_code(code, mode)  # set the new mode en code
                        index = i
                    else:  # code object does not yet exist
                        index_child = chapter.child(index)
                        # add the new object under the indexed child
                        chapter.code_items.insert(index,
                                                  CodeItem(chapter, chapter.name, mode,
                                                           compare_code=code, preceding=index_child))
                        index += 1

        self.get_dependencies(gui)
        self.get_dependees(gui)

        # formatting the tree items
        if gui & GUI_SELECT:
            for _, code_item in self.get_code_items():
                if code_item.dependees:
                    code_item.set_color(RED)
            for chapter in self.chapters:
                chapter.set_gui(gui)
                chapter.set_color_based_on_children(gui, color=WHITE)
                if chapter.childCount() == 0:
                    chapter.setCheckState(0, UNCHECKED)

        elif gui & GUI_COMPARE:
            for _, code_item in self.get_code_items():
                if code_item.color == RED:
                    code_item.setCheckState(0, UNCHECKED)
            for chapter in self.chapters:
                chapter.set_gui(gui)
                chapter.set_color_based_on_children(gui)
                if chapter.childCount() == 0:
                    chapter.setCheckState(0, UNCHECKED)

        logger.debug('Finished parsing data.')

    def get_dependencies(self, gui: int):
        """Method with nifty code to extract en fill direct dependencies.

        Per code object upon other objects based on their vql code.
        :param gui: mode flag selector indicating what code is done
        :type gui: int
        :return: None
        :rtype: None
        """

        # place holder in search strings that is unlikely in the code
        place_holder = '%&*&__&*&%'

        # helper function
        def find_dependencies(_code_objects, _underlying_code_objects, _search_template):
            """
            Function finds and adds the direct dependencies of code objects
            in the lower-cased code of underlying objects.
            Basically it looks for the code_item's object name in the code of the underlying objects
            via a particular search string per chapter type
            :param _code_objects: a list of tuples (code object, object name, code)
            :type _code_objects: list(tuple(CodeItem, str, str))
            :param _underlying_code_objects: a list of tuples (code object, object name, code) of underlying objects
            :type _underlying_code_objects: list(tuple(CodeItem, str, str))
            :param _search_template: a template for the search string in which the object names can be put
            :type _search_template: str
            :return: None
            :rtype: None
            """

            for code_object, code_object_name, code in _code_objects:
                for other_code_item, other_name, other_code in _underlying_code_objects:
                    search_string = _search_template.replace(place_holder, other_name)
                    if not code.find(search_string) == -1:
                        if gui & GUI_SELECT:
                            code_object.dependencies.append(other_code_item)
                        elif gui & GUI_COMPARE:
                            code_object.compare_dependencies.append(other_code_item)

        # helper function
        def code_items_lower(_code_object_chapter_name):
            """
            Returns a list of code items with their code and object names in lower case of a particular chapter
            :param _code_object_chapter_name: the chapter name
            :type _code_object_chapter_name: str
            :return: the requested list of tuples
            :rtype: list(tuple(CodeItem, str, str))
            """
            items = None
            if gui & GUI_SELECT:
                items = [(code_item, code_item.object_name.lower(), code_item.code.lower())
                         for code_item in self.get_chapter_by_name(_code_object_chapter_name).code_items]
            elif gui & GUI_COMPARE:
                items = [(code_item, code_item.object_name.lower(), code_item.compare_code.lower())
                         for code_item in self.get_chapter_by_name(_code_object_chapter_name).code_items]
            return items

        # construct the searches in a list of tuples:
        # 1 the items analysed
        # 2 the underlying items
        # 3 the search string template

        searches = list()
        searches.append(('WRAPPERS', 'DATASOURCES', f"datasourcename={place_holder}"))
        searches.append(('BASE VIEWS', 'WRAPPERS', f"wrapper (jdbc {place_holder})"))
        searches.append(('BASE VIEWS', 'WRAPPERS', f"wrapper (df {place_holder})"))
        searches.append(('BASE VIEWS', 'WRAPPERS', f"wrapper (ldap {place_holder})"))

        for i in range(15):
            parentheses = '(' * i
            searches.append(('VIEWS', 'BASE VIEWS', f"from {parentheses}{place_holder}"))
            searches.append(('VIEWS', 'BASE VIEWS', f"join {parentheses}{place_holder}"))
        # searches.append(('VIEWS', 'BASE VIEWS', f"from {place_holder}"))
        # searches.append(('VIEWS', 'BASE VIEWS', f"from ({place_holder}"))
        # searches.append(('VIEWS', 'BASE VIEWS', f"join {place_holder}"))
        searches.append(('VIEWS', 'BASE VIEWS', f"set implementation {place_holder}"))
        searches.append(('VIEWS', 'BASE VIEWS', f"datamovementplan = {place_holder}"))

        # searches.append(('VIEWS', 'VIEWS', f"from {place_holder}"))
        for i in range(15):
            parentheses = '(' * i
            searches.append(('VIEWS', 'VIEWS', f"from {parentheses}{place_holder}"))
            searches.append(('VIEWS', 'VIEWS', f"join {parentheses}{place_holder}"))
        searches.append(('VIEWS', 'VIEWS', f"set implementation {place_holder}"))
        searches.append(('VIEWS', 'VIEWS', f"datamovementplan = {place_holder}"))

        searches.append(('ASSOCIATIONS', 'VIEWS', f" {place_holder} "))

        # perform the searches and store dependencies
        for chapter_name, underlying_chapter_name, search_template in searches:
            code_objects = code_items_lower(chapter_name)
            underlying_code_objects = code_items_lower(underlying_chapter_name)
            find_dependencies(code_objects, underlying_code_objects, search_template)

    def get_dependees(self, gui: int):
        """Method that fills the code item's dependees list.

        Only direct dependees (objects that depend on this object) are stored.
        :param gui: The mode flag of operation
        :type gui: int
        :return: None
        :rtype: None
        """

        for chapter, item in self.get_code_items():
            # make unique
            dependencies = None
            dependees = None

            if gui & GUI_SELECT:
                dependencies = item.dependencies
                dependees = item.dependees
            elif gui & GUI_COMPARE:
                dependencies = item.compare_dependencies
                dependees = item.compare_dependees

            dependencies = self.unique_list(dependencies)

            # remove item itself (maybe from a join on itself)
            if item in dependencies:
                dependencies.remove(item)

            # construct list of dependees, of which this item is a parent
            for item_dependency in dependencies:
                if gui & GUI_SELECT:
                    item_dependency.dependees.append(item)
                elif gui & GUI_COMPARE:
                    item_dependency.compare_dependees.append(item)

            dependees = self.unique_list(dependees)

            if gui & GUI_SELECT:
                item.dependencies = dependencies
                item.dependees = dependees
            elif gui & GUI_COMPARE:
                item.compare_dependencies = dependencies
                item.compare_dependees = dependees

    @staticmethod
    def unique_list(_list: list):
        """Function that turns a list into a list with unique items.

        Keeping the sort order.

        :param _list: the list to make unique
        :type _list: list
        :return: the list made unique
        :rtype: list
        """
        new_list = list()
        for item in _list:
            if item not in new_list:
                new_list.append(item)
        return new_list

    def change_view(self, mode: int)->bool:
        """Method that swaps the tree items from VQL View to Denodo file structure view and back.

        The actual switch is done in switch_view function.
        This function handles the surrounding aspects.

        :param mode: the mode flag with bits for the new view either VQL_VIEW or DENODO_VIEW
        :type mode: int
        :return: Success or not
        :rtype: bool
        """

        gui = mode & (GUI_NONE | GUI_SELECT | GUI_COMPARE)
        if self.view & mode:
            return True

        if mode & VQL_VIEW:
            if self.storage_list:
                self.switch_view()
                self.view = VQL_VIEW
                return True
            else:
                # build a VQL_View
                pass
        elif mode & DENODO_VIEW:
            if self.storage_list:
                self.switch_view()
                self.view = DENODO_VIEW
                return True
            else:
                # build denodo view
                if self.build_denodo_view(gui):
                    self.change_view(mode)
        return False

    def switch_view(self):
        """Method to switch view between VQL or Denodo file structure.

        Store the children of the root item of the tree widget
        and replace them with the stored ones.
        :return: None
        :rtype: None
        """

        temp = self.root.takeChildren()
        self.root.addChildren(self.storage_list)
        self.storage_list = temp

    def build_denodo_view(self, gui: int)->bool:
        """Method that builds up the Denodo folder structure.

        Using chapter items as folders and adds code_items as children.
        This structure is stored in the storage list
        and shown when the view is switched.
        :param gui: flag to indicate compare or normal select operations
        :type gui: int
        :return: Success or not
        :rtype: bool
        """

        folders = dict()
        self.pack()
        # get the list of folders and all code items in them
        for chapter, code_item in self.get_code_items():
            if code_item.denodo_folder not in folders.keys():
                folders[code_item.denodo_folder] = list()
                folders[code_item.denodo_folder].append(code_item)
            else:
                folders[code_item.denodo_folder].append(code_item)

        temp_widget = VqlModel(None)
        temp_root = temp_widget.denodo_root

        old_depth = 1
        parent_item = temp_root
        folder_item = None
        for folder, code_items in folders.items():
            if folder:
                folder_split = folder.split('/')
                last_folder = folder_split[-1]
                new_depth = len(folder_split)
                if new_depth == 1:
                    parent_item = temp_root
                else:
                    if new_depth > old_depth:
                        parent_item = folder_item
                folder_item = Chapter(parent_item, last_folder)
                if parent_item is not temp_root:
                    parent_item.chapter_items.append(folder_item)
                    folder_item.gui = parent_item.gui
                old_depth = new_depth

                for code_item in code_items:
                    item = CodeItem(folder_item, code_item.chapter_name, code_item.mode,
                                    code=code_item.code, compare_code=code_item.compare_code)

                    folder_item.code_items.append(item)

                    item.setCheckState(0, code_item.checkState(0))
                folder_item.set_gui(gui)
                folder_item.set_color_based_on_children(gui)
            else:
                return False

        self.storage_list = temp_root.takeChildren()
        return True

    def remove_compare(self):
        """Method to remove compare code .

        It resets the items as if still in the GUI_SELECT state.
        :return: None
        :rtype: None
        """
        for _, item in self.get_code_items():
            item.remove_compare()


class DependencyViewer(QWidget):
    """
    Dependency viewer: a window to investigate code objects that are dependent
    on the currently selected, right mouse clicked item in the selection tree view
    """
    def __init__(self, mode: int, code_item: CodeItem, pos: QPoint, parent=None):
        """
        Class Constructor
        :param mode: either GUI_SELECT or GUI_COMPARE
        :param code_item: the code item whose dependees are shown
        :param pos: pos of the window
        :param parent: parent object for this window
        """

        def recurse(n_recurses, _mode: int, _code_item: CodeItem, _child: QTreeWidgetItem):
            """

            :param n_recurses:
            :param _mode:
            :param _code_item:
            :param _child:
            :return:
            """
            n_recurses += 1
            if n_recurses > 100:
                return
            _child.setText(0, _code_item.chapter_name[:-1] + ' : ' + _code_item.object_name)
            dependees = None
            if _mode & GUI_SELECT:
                dependees = _code_item.dependees
            elif _mode & GUI_COMPARE:
                dependees = _code_item.compare_dependees
            for _code_item1 in dependees:
                _child1 = _code_item1.clone()
                _child1.setText(0, _code_item1.chapter_name[:-1] + ' : ' + _code_item1.object_name)
                _child.addChild(_child1)
                recurse(n_recurses, _mode, _code_item1, _child1)

        super(DependencyViewer, self).__init__(parent)
        # self.setGeometry(300, 400)
        self.resize(400, 400)
        self.move(pos)
        self.setMinimumSize(QSize(180, 240))
        if mode & GUI_SELECT:
            self.setWindowTitle('Depencency Viewer')
        elif mode & GUI_COMPARE:
            self.setWindowTitle('Depencency Viewer Compare Code')

        self.setWindowFlags(Qt.Window | Qt.WindowStaysOnTopHint)
        layout = QGridLayout(self)

        root_node = code_item.clone()
        header = 'Dependencies on ' + code_item.object_name
        self.dependency_tree = VQLManagerWindow.create_tree_widget(self, QTreeWidget, ITEM_FLAG_SEL, header=header)
        scroll = QScrollArea()
        scroll.setWidget(self.dependency_tree)
        recurse(0, mode, code_item, root_node)
        children = root_node.takeChildren()
        if children:
            self.dependency_tree.addTopLevelItems(children)
        else:
            non_item = QTreeWidgetItem()
            non_item.setText(0, 'None')
            self.dependency_tree.addTopLevelItem(non_item)

        # self.dependency_tree.addTopLevelItem(root_node)
        self.dependency_tree.expandAll()
        VQLManagerWindow.remove_checkboxes(self.dependency_tree)
        layout.addWidget(self.dependency_tree, 0, 0)
        self.setLayout(layout)

    @staticmethod
    def get_viewer(mode: int, code_item: CodeItem, pos: QPoint, parent=None):
        """
        Returns the dependency viewer
        :param mode: the mode
        :param code_item: the code item whose depedees are shown
        :param pos: position of the code_item
        :param parent: parent
        :return: None
        """
        viewer = DependencyViewer(mode, code_item, pos, parent)
        result = viewer.show()
        return result


class VQLManagerWindow(QMainWindow):
    """
    Main Gui Class.
    """
    def __init__(self, parent=None):
        """
        Constructor of the Window Class
        :param parent: The owner/parent of the instance
        :type parent: Qt.Window
        :rtype: None
        """
        logger.info("Start Window creation")
        # initialize main window calling its parent
        super(VQLManagerWindow, self).__init__(parent, Qt.Window)
        self.setAttribute(Qt.WA_DeleteOnClose)  # close children on exit
        # root is the folder from which this file runs
        self._root = Path(QFileInfo(__file__).absolutePath())
        images = self._root / 'images'

        self.resize(1200, 800)
        self.setMinimumSize(QSize(860, 440))
        self.setIconSize(QSize(32, 32))
        self.setWindowIcon(QIcon(str(images / 'splitter.png')))
        self.setWindowTitle(APPLICATION_NAME)

        self.select_button_labels = {'All': white, 'Lost': red, 'New': green, 'Same': white, 'Changed': yellow}
        self.diff_button_labels = {'Original': white, 'New': green, 'Changes': yellow}

        # instantiate widgets
        self.mainwidget = QWidget(self, flags=Qt.Widget)
        self.layout = QGridLayout(self.mainwidget)

        # create radio buttons
        self.select_buttons, self.select_buttons_group = \
            self.get_buttons_widget(self.mainwidget, self.select_button_labels)
        self.diff_buttons, self.diff_buttons_group = \
            self.get_buttons_widget(self.mainwidget, self.diff_button_labels)

        # create tree widgets VqlModel(self.mainwidget)
        self.all_chapters_treeview = self.create_tree_widget(self.mainwidget, VqlModel, ITEM_FLAG_CHAPTER,
                                                             header='Selection Pane',
                                                             tooltip="")

        self.selected_treeview = self.create_tree_widget(self.mainwidget, QTreeWidget, ITEM_FLAG_SEL,
                                                         header='View Pane',
                                                         tooltip="Selected parts: Click to view source code")

        # create labels
        self.code_text_edit_label = QLabel(self.mainwidget)
        self.mode_label = QLabel(self.mainwidget)
        self.base_repository_label = QLabel(self.mainwidget)
        self.compare_repository_label = QLabel(self.mainwidget)
        self.selection_viewer_label = QLabel(self.mainwidget)

        # create source code view
        self.code_text_edit = QTextEdit(self.mainwidget)

        # create statusbar
        self.statusBar = QStatusBar(self)

        #  Create Actions and Menubar ###############################################################################
        self.open_file_action = QAction(QIcon(str(images / 'open_file.png')), '&Open File', self)
        self.open_folder_action = QAction(QIcon(str(images / 'open_repo.png')), 'Open &Repository', self)
        self.export_file_action = QAction(QIcon(str(images / 'save_file.png')), 'Save As File', self)
        self.export_folder_action = QAction(QIcon(str(images / 'save_repo.png')), '&Save As Repository', self)
        self.exit_action = QAction(QIcon(str(images / 'exit.png')), '&Exit', self)

        # Create recent file menu
        self.recent_file_actions = list()
        self.recent_repository_actions = list()
        self.compare_recent_file_actions = list()
        self.compare_recent_repository_actions = list()

        for i in range(MAX_RECENT_FILES):
            action = QAction(self)
            action.setVisible(False)
            action.triggered.connect(partial(self.on_open_recent_files, i, GUI_SELECT | BASE_FILE))
            self.recent_file_actions.append(action)
            action = QAction(self)
            action.setVisible(False)
            action.triggered.connect(partial(self.on_open_recent_files, i, GUI_SELECT | BASE_REPO))
            self.recent_repository_actions.append(action)
            action = QAction(self)
            action.setVisible(False)
            action.triggered.connect(partial(self.on_open_recent_files, i, GUI_COMPARE | COMP_FILE))
            self.compare_recent_file_actions.append(action)
            action = QAction(self)
            action.setVisible(False)
            action.triggered.connect(partial(self.on_open_recent_files, i, GUI_COMPARE | COMP_REPO))
            self.compare_recent_repository_actions.append(action)

        # create compare with File menu
        self.open_compare_file_action = \
            QAction(QIcon(str(images / 'open_file.png')), '&Open File to Compare', self)
        self.open_compare_folder_action = \
            QAction(QIcon(str(images / 'open_repo.png')), 'Open &Repository to Compare', self)
        self.denodo_folder_structure_action = \
            QAction(QIcon(str(images / 'open_repo.png')), 'Denodo Folder Structure', self)

        # Reset everything
        self.reset_action = QAction(QIcon(str(images / 'reset.png')), 'Reset &Everything', self)
        # create about actions
        self.about_action = QAction("&About", self)
        self.about_qt_action = QAction("About &Qt", self)

        # Menu
        self.menubar = QMenuBar(self)
        self.filemenu = QMenu()
        self.recent_file_separator = None
        self.recent_file_menu = QMenu()
        self.recent_repository_separator = None
        self.recent_repository_menu = QMenu()

        self.compare_menu = QMenu()
        self.compare_recent_file_menu = QMenu()
        self.compare_recent_repository_menu = QMenu()
        self.compare_recent_repository_separator = None
        self.compare_recent_file_separator = QMenu()

        self.help_menu = QMenu()

        self.options_menu = QMenu()
        self.update_timer = QTimer()

        self.all_chapters_treeview.setContextMenuPolicy(Qt.CustomContextMenu)
        self.all_chapters_treeview.customContextMenuRequested.connect(self.on_right_click)

        # Format and setup all widgets
        self.setup_ui()

        # Initialize class properties ###########################################################################
        self.last_clicked_class_type = None
        self.working_folder = None
        self.base_repository_file = None
        self.base_repository_folder = None
        self.compare_repository_file = None
        self.compare_repository_folder = None

        self._mode = 0

        self.switch_to_mode(GUI_NONE)
        self.code_show_selector = ORIGINAL_CODE
        self.code_text_edit_cache = None
        logger.info("Finished Window creation")

    @staticmethod
    def create_tree_widget(parent: QWidget, class_type, flags: int, header=None, tooltip=None)\
            ->Union[VqlModel, QTreeWidget]:
        """Factory for instances of a QTreeWidget or VqlModel

        :param parent: The parent of the widget, in which it is placed
        :type parent: QWidget
        :param class_type: Either a QTreeWidget or an inherited VqlModel
        :type class_type: class
        :param flags: the flags on the QTreeWidget
        :type flags: int
        :param header: The header of the widget
        :type header: str
        :param tooltip: Initial tooltip
        :type tooltip: str
        :return: the TreeWidget created
        :rtype: VqlModel or QTreeWidget
        """
        tree_widget = class_type(parent)
        tree_widget.invisibleRootItem().setFlags(flags)
        tree_widget.setEditTriggers(QAbstractItemView.NoEditTriggers)
        tree_widget.setSelectionMode(QAbstractItemView.NoSelection)
        tree_widget.setUniformRowHeights(True)
        if header:
            tree_widget.setHeaderLabel(header)
        if tooltip:
            tree_widget.setToolTip(tooltip)
        tree_widget.setToolTipDuration(2000)
        tree_widget.setColumnCount(1)
        return tree_widget

    def new_tree_data(self, mode: int)->int:
        """Function resets the data in the trees so the are new and shiny.

        :param mode: Flags
        :type mode: int
        :return: the new mode
        :rtype: int
        """

        new_mode = GUI_NONE
        if mode & GUI_NONE:
            self.all_chapters_treeview.clear()
            self.selected_treeview.clear()
            self.all_chapters_treeview = self.create_tree_widget(
                self.mainwidget, VqlModel, ITEM_FLAG_CHAPTER, header='Selection Pane', tooltip="")

            self.selected_treeview = self.create_tree_widget(
                self.mainwidget, QTreeWidget, ITEM_FLAG_SEL, header='View Pane',
                tooltip="Selected parts: Click to view source code")
            new_mode = GUI_NONE

        elif mode & GUI_SELECT:
            self.all_chapters_treeview.remove_compare()
            strip_list = [GUI_COMPARE, COMP_REPO, COMP_FILE, COMP_LOADED]
            new_mode = self.mode_strip(self.get_mode(), strip_list)
        return new_mode

    @staticmethod
    def mode_strip(mode: int, strip_list: List[int])->int:
        """Removes flags in the strip_list from the mode flag.

        Normally this is done with mode = mode & ~flag , but since python has not unsigned integers we use subtract
        :param mode: the mode flags
        :type mode: int
        :param strip_list: the flag to remove
        :type strip_list: list(int)
        :return: an new mode without stripped flags
        :rtype: int
        """
        for constant in strip_list:
            if mode & constant:
                mode -= constant
        return mode

    @staticmethod
    def resize_widget(some_widget: QWidget):
        """Sets size policy on the widget

        :param some_widget: a widget
        :type some_widget: QWidget
        :return: None
        :rtype: None
        """
        some_widget.setMinimumSize(QSize(PANE_WIDTH, 0))
        some_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

    def setup_ui(self):
        """Function setup up all widgets

        :return: None
        :rtype: None
        """
        logger.debug("Start setup window ui")
        self.layout.setContentsMargins(23, 23, 23, 23)
        self.layout.setSpacing(8)

        # Add Widgets ####################################################################################

        self.resize_widget(self.all_chapters_treeview)
        self.resize_widget(self.selected_treeview)
        self.resize_widget(self.code_text_edit_label)
        self.resize_widget(self.mode_label)
        self.resize_widget(self.selection_viewer_label)
        self.resize_widget(self.compare_repository_label)
        self.resize_widget(self.base_repository_label)
        self.resize_widget(self.code_text_edit)
        self.resize_widget(self.select_buttons)
        self.resize_widget(self.diff_buttons)

        self.select_buttons.setHidden(True)
        self.diff_buttons.setHidden(True)
        self.code_text_edit.setLineWrapMode(0)
        self.code_text_edit.setReadOnly(True)
        self.code_text_edit.setText("non selected")
        self.code_text_edit_label.setText("Command:")

        #  Layout ################################################################################
        # left pane
        self.layout.addWidget(self.mode_label,                0, 0, 1, 2)
        self.layout.addWidget(self.base_repository_label,     1, 0, 1, 2)
        self.layout.addWidget(self.compare_repository_label,  2, 0, 1, 2)
        self.layout.addWidget(self.select_buttons,            3, 0, 1, 1)
        self.layout.addWidget(self.all_chapters_treeview,     4, 0, 4, 1)

        # right pane

        self.layout.addWidget(self.selection_viewer_label,  3, 1, 1, 1)
        self.layout.addWidget(self.selected_treeview,       4, 1, 1, 1)
        self.layout.addWidget(self.code_text_edit_label, 5, 1, 1, 1)
        self.layout.addWidget(self.diff_buttons,            6, 1, 1, 1)
        self.layout.addWidget(self.code_text_edit, 7, 1, 1, 1)

        self.layout.setRowStretch(0, 1)
        self.layout.setRowStretch(1, 1)
        self.layout.setRowStretch(2, 1)
        self.layout.setRowStretch(3, 1)

        self.layout.setRowStretch(4, 12)
        self.layout.setRowStretch(5, 1)
        self.layout.setRowStretch(6, 1)
        self.layout.setRowStretch(7, 12)

        self.layout.setColumnStretch(0, 1)
        self.layout.setColumnStretch(1, 2)

        self.statusBar.setMinimumSize(QSize(0, 20))
        self.statusBar.showMessage("Ready")
        self.setStatusBar(self.statusBar)

        # Parent mainWidget to the QMainWindow
        self.setCentralWidget(self.mainwidget)

        #  Actions and Menubar ###############################################################################
        # Open File
        self.open_file_action.setShortcut('Ctrl+O')
        self.open_file_action.setStatusTip('Open Single VQL File')
        self.open_file_action.triggered.connect(lambda: self.on_open(GUI_SELECT | BASE_FILE))

        # Open Repository
        self.open_folder_action.setShortcut('Ctrl+R')
        self.open_folder_action.setStatusTip('Open a repository containing folders with separate vql scripts')
        self.open_folder_action.triggered.connect(lambda: self.on_open(GUI_SELECT | BASE_REPO))

        # Save As File
        self.export_file_action.setStatusTip('Save selection to a repository file')
        self.export_file_action.triggered.connect(lambda: self.on_save(FILE))

        # Save As Repository
        self.export_folder_action.setShortcut('Ctrl+S')
        self.export_folder_action.setStatusTip('Save selection to a repository folder')
        self.export_folder_action.triggered.connect(lambda: self.on_save(REPO))

        # Exit App
        self.exit_action.setShortcut('Ctrl+Q')
        self.exit_action.setStatusTip('Exit application')
        self.exit_action.triggered.connect(QApplication.quit)

        # Compare with File
        self.open_compare_file_action.setShortcut('Ctrl+O')
        self.open_compare_file_action.setStatusTip('Open Single VQL File')
        self.open_compare_file_action.triggered.connect(lambda: self.on_open(GUI_COMPARE | COMP_FILE))

        # Compare with Folder
        self.open_compare_folder_action.setShortcut('Ctrl+R')
        self.open_compare_folder_action.setStatusTip('Open a repository containing folders with separate vql scripts')
        self.open_compare_folder_action.triggered.connect(lambda: self.on_open(GUI_COMPARE | COMP_REPO))

        self.denodo_folder_structure_action.setShortcut('Ctrl+D')
        self.denodo_folder_structure_action.setStatusTip('Switch to DENODO View')
        self.denodo_folder_structure_action.setCheckable(True)
        self.denodo_folder_structure_action.triggered.connect(self.on_switch_view)

        # Reset everything
        self.reset_action.setStatusTip('Reset the application to a clean state')
        self.reset_action.triggered.connect(self.on_reset)

        self.about_action.setStatusTip("Show the application's About box")
        self.about_action.triggered.connect(self.on_about_vql_manager)
        self.about_qt_action.setStatusTip("Show the Qt library's About box")
        self.about_qt_action.triggered.connect(self.on_about_qt)

        #  Menu
        self.menubar.setGeometry(QRect(0, 0, 1200, 23))

        self.filemenu = self.menubar.addMenu('&File')
        self.filemenu.addAction(self.open_file_action)
        self.filemenu.addAction(self.open_folder_action)
        self.filemenu.addAction(self.export_file_action)
        self.filemenu.addAction(self.export_folder_action)

        self.recent_file_separator = self.filemenu.addSeparator()
        self.recent_file_menu = self.filemenu.addMenu('Recent Files')
        for i in range(MAX_RECENT_FILES):
            self.recent_file_menu.addAction(self.recent_file_actions[i])

        self.recent_repository_separator = self.filemenu.addSeparator()
        self.recent_repository_menu = self.filemenu.addMenu('Recent Repositories')
        for i in range(MAX_RECENT_FILES):
            self.recent_repository_menu.addAction(self.recent_repository_actions[i])

        self.filemenu.addSeparator()
        self.filemenu.addAction(self.exit_action)

        self.compare_menu = self.menubar.addMenu('&Compare')
        self.compare_menu.addAction(self.open_compare_file_action)
        self.compare_menu.addAction(self.open_compare_folder_action)

        self.compare_recent_file_separator = self.compare_menu.addSeparator()
        self.compare_recent_file_menu = self.compare_menu.addMenu('Recent Files')
        for i in range(MAX_RECENT_FILES):
            self.compare_recent_file_menu.addAction(self.compare_recent_file_actions[i])

        self.compare_recent_repository_separator = self.compare_menu.addSeparator()
        self.compare_recent_repository_menu = self.compare_menu.addMenu('Recent Repositories')
        for i in range(MAX_RECENT_FILES):
            self.compare_recent_repository_menu.addAction(self.compare_recent_repository_actions[i])

        self.update_recent_file_actions()

        self.options_menu = self.menubar.addMenu('&Options')
        self.options_menu.addAction(self.denodo_folder_structure_action)
        self.options_menu.addSeparator()
        self.options_menu.addAction(self.reset_action)

        self.help_menu = self.menubar.addMenu('&Help')
        self.help_menu.addAction(self.about_action)
        self.help_menu.addAction(self.about_qt_action)

        # Callbacks Slots and Signals #####################################################
        self.all_chapters_treeview.itemClicked.connect(self.on_selection_clicked)
        self.all_chapters_treeview.itemChanged.connect(self.on_selection_changed)
        self.selected_treeview.itemClicked.connect(self.on_click_item_selected)

        # Radio buttons
        self.select_buttons_group.buttonClicked.connect(self.on_select_buttons_clicked)
        self.diff_buttons_group.buttonClicked.connect(self.on_diff_buttons_clicked)

        # connect update timer
        self.update_timer.timeout.connect(self.update_tree_widgets)
        logger.debug("Finished setup window ui")

    def update_recent_file_actions(self):
        """Upates the Action objects in the menu to reflect the recent file storage.

        :return: None
        :rtype: None
        """
        settings = QSettings(COMPANY, APPLICATION_NAME)
        files = settings.value(RECENT_FILES, type=list)
        repositories = settings.value(RECENT_REPOSITORIES, type=list)

        len_files = len(files)
        len_repositories = len(repositories)

        menus = [self.recent_file_actions, self.compare_recent_file_actions]
        for actions in menus:
            for i in range(MAX_RECENT_FILES):
                if i < len_files:
                    file = Path(files[i])
                    text = str(i + 1) + ': ' + str(file.name)
                    actions[i].setText(text)
                    actions[i].setData(file)
                    actions[i].setVisible(True)
                    actions[i].setStatusTip(str(file))
                else:
                    actions[i].setVisible(False)

        menus = [self.recent_repository_actions, self.compare_recent_repository_actions]
        for actions in menus:
            for i in range(MAX_RECENT_FILES):
                if i < len_repositories:
                    repository = Path(repositories[i])
                    text = str(i + 1) + ': ' + str(repository.name)
                    actions[i].setText(text)
                    actions[i].setData(repository)
                    actions[i].setVisible(True)
                    actions[i].setStatusTip(str(repository))
                else:
                    actions[i].setVisible(False)

        if len_files > 0:
            self.recent_file_separator.setVisible(True)
            self.compare_recent_file_separator.setVisible(True)
        else:
            self.recent_file_separator.setVisible(False)
            self.compare_recent_file_separator.setVisible(False)

        if len_repositories > 0:
            self.recent_repository_separator.setVisible(True)
            self.compare_recent_repository_separator.setVisible(True)
        else:
            self.recent_repository_separator.setVisible(False)
            self.compare_recent_repository_separator.setVisible(False)

    def get_all_dependees(self, item: CodeItem, items=list())->List[CodeItem]:
        """Recursive function to gather all the items that are dependent on this one.

        :param item: a CodeItem object
        :type item: CodeItem
        :param items: the list of dependees
        :type items: list(CodeItems)
        :return: the list of dependees
        :rtype: list(CodeItems)
        """
        for item in item.dependees:
            items.append(item)
            self.get_all_dependees(item, items)
        else:
            return items

    @staticmethod
    def get_buttons_widget(main_widget: QWidget, button_dict: dict)->Tuple[QWidget, QButtonGroup]:
        """Constructs a series of related radio buttons used to filter CodeItems.

        :param main_widget: the parent widget
        :type main_widget: QWidget
        :param button_dict: A dict with names and colors
        :type button_dict: dict
        :return: A tuple of widget and the group its in
        :rtype: tuple(Qwidget, QWidgetGroup)
        """
        layout = QHBoxLayout()  # layout for the central widget
        widget = QWidget(main_widget)  # central widget
        widget.setLayout(layout)
        group = QButtonGroup(widget)  # Number group
        first_button = True
        for text, label_color in button_dict.items():
            btn = QRadioButton(text)
            btn.setStyleSheet("color: " + label_color)
            if first_button:
                btn.setChecked(True)
                first_button = False
            group.addButton(btn)
            layout.addWidget(btn, 0, Qt.AlignLeft)
        return widget, group

    def get_mode(self)->int:
        """Getter for the mode flag

        :return: the current mode
        :rtype: int
        """
        return self._mode

    def switch_to_mode(self, new_mode: int):
        """Redresses the window to reflect the new mode
        :param new_mode: the new mode
        :return: None
        :rtype: None
        """
        logger.debug("Starting setting mode: " + show_mode(new_mode))
        if new_mode & GUI_NONE or new_mode == 0:
            self.mode_label.setText('View Mode: None')
            self.base_repository_label.setText('No file loaded')
            self.compare_repository_label.setText('')
            self.all_chapters_treeview.setHeaderLabel('Selection Pane')
        elif new_mode & GUI_SELECT:
            self.mode_label.setText("View Mode: Selection")
            self.diff_buttons.setHidden(True)
            self.select_buttons.setHidden(True)
            if new_mode & BASE_LOADED:
                if new_mode & BASE_FILE:
                    self.base_repository_label.setText('File : ' + str(self.base_repository_file))
                elif new_mode & BASE_REPO:
                    self.base_repository_label.setText('Repository : ' + str(self.base_repository_folder))
            self.compare_repository_label.setText('')
        elif new_mode & GUI_COMPARE:
            self.mode_label.setText("View Mode: Compare")
            self.diff_buttons.setHidden(False)
            self.select_buttons.setHidden(False)
            if new_mode & COMP_LOADED:
                if new_mode & COMP_FILE:
                    self.compare_repository_label.setText('File : ' + str(self.compare_repository_file))
                elif new_mode & COMP_REPO:
                    self.compare_repository_label.setText('Repository : ' + str(self.compare_repository_folder))
        if new_mode & VQL_VIEW:
            self.denodo_folder_structure_action.setChecked(False)
            self.on_switch_view()

        self.all_chapters_treeview.switch_mode(new_mode)
        self._mode = new_mode
        # self.statusBar.showMessage(show_mode(self._mode))
        logger.debug("Finished setting mode: " + show_mode(self._mode))

    # Event handlers for opening and saving models

    def on_open_recent_files(self, index: int, mode: int):
        """Event handler for the click on a recent files menu item.

        This function collects the data from the OS storage about the recent file/repo list
        and initiates a loading process.

        :param index: Index of the menu item clicked
        :type index: int
        :param mode: mode flag of the application
        :type: int
        :return: None
        :rtype: None
        """

        if mode & FILE:
            file_list = RECENT_FILES
        elif mode & REPO:
            file_list = RECENT_REPOSITORIES
        else:
            return

        settings = QSettings(COMPANY, APPLICATION_NAME)
        files = settings.value(file_list, type=list)

        if files:
            file = files[index]
            self.on_open(mode, file)

    def on_select_buttons_clicked(self, button: QRadioButton):
        """Event handler for the radio buttons in the left pane.

        To filter the VqlModel tree based on color of the items.
        :param button: the button clicked
        :type button: QRadioButton
        :return: None
        :rtype: None
        """
        if button.text() == 'All':
            color = None
        else:
            color = translate_colors(self.select_button_labels[button.text()], to_text=False)
        self.all_chapters_treeview.color_filter = color
        self.update_tree_widgets()

    def on_diff_buttons_clicked(self, button: QRadioButton):
        """Event handler for the radio buttons in the right pane.

        To filter the view in the code edit widget.
        :param button: the button clicked
        :type button: QRadioButton
        :return: None
        :rtype: None
        """

        text = button.text()
        if text == 'Original':
            self.code_show_selector = ORIGINAL_CODE
        elif text == 'New':
            self.code_show_selector = COMPARE_CODE
        elif text == 'Changes':
            self.code_show_selector = DIFF_CODE
        self.show_code_text()

    def on_open(self, new_mode: int, load_path=None):
        """Event handler Open File menu items and Compare open items.

        This function is the starting point for loading a model based on a .vql file or a repository
        :param new_mode: the mode of opening
        :type new_mode: int
        :param load_path: optional parameter for loading from a recent file list
        :type load_path: Path
        :return: None
        :rtype: None
        """
        logger.info(f"Open file or repository {load_path if load_path else ''} in mode: {show_mode(new_mode)} mode.")
        file = None
        folder = None

        if load_path:
            if new_mode & FILE:
                    file = Path(load_path)
            elif new_mode & REPO:
                    folder = Path(load_path)
            else:
                return

        current_mode = self.get_mode()

        if new_mode & GUI_SELECT:
            if current_mode & (BASE_LOADED | COMP_LOADED):
                # some base model is open:
                if self.ask_drop_changes():
                    self.switch_to_mode(self.new_tree_data(GUI_NONE))
                    self.on_open(new_mode)  # recurse to the begin
                else:
                    return
            else:  # ok we can load
                if new_mode & BASE_FILE:
                    if not file:
                        file = self.ask_file_open()
                    if file:
                        self.run(self.load_model_from_file(file, BASE_FILE | GUI_SELECT))
                elif new_mode & BASE_REPO:
                    if not folder:
                        folder = self.ask_repository_open()
                    if folder:
                        self.run(self.load_model_from_repository(folder, BASE_REPO | GUI_SELECT))

        elif new_mode & GUI_COMPARE:
            if not current_mode & BASE_LOADED:  # there is a base model
                message_to_user("No repository loaded yet", parent=self)
                return

            if current_mode & COMP_LOADED:  # there is a compare going on
                if self.ask_drop_changes():
                    self.switch_to_mode(self.new_tree_data(GUI_SELECT))
                    self.on_open(new_mode)  # recurse to the begin
                else:
                    return
            else:  # ok we can load
                if new_mode & COMP_FILE:
                    if not file:
                        file = self.ask_file_open()
                    if file:
                        self.run(self.load_model_from_file(file, COMP_FILE | GUI_COMPARE))
                elif new_mode & COMP_REPO:
                    if not folder:
                        folder = self.ask_repository_open()
                    if folder:
                        self.run(self.load_model_from_repository(folder, COMP_REPO | GUI_COMPARE))
        logger.info("File or repository loaded.")

    def on_right_click(self, pos: QPoint):
        """Event handler for the right click event on the all_chapter_treeview widget.

        :param pos: position of the click
        :return: None
        :rtype: None
        """
        if pos:
            item = self.all_chapters_treeview.itemAt(pos)
            if item.class_type == CodeItem:
                if self._mode & GUI_SELECT:
                    DependencyViewer.get_viewer(self._mode, item, pos, self)
                elif self._mode & GUI_COMPARE:
                    if item.compare_code:
                        DependencyViewer.get_viewer(self._mode, item, pos, self)
                    else:
                        message_to_user('This item does not exist in the new (compare) code base', parent=self)

    @staticmethod
    def run(task):
        """Function to start asynchronous tasks.

        :param task: A future function to be ran
        :return: None
        :rtype: None
        """

        if task:
            loop = asyncio.new_event_loop()
            loop.run_until_complete(task)
            loop.close()

    def on_save(self, save_mode: int):
        """Event handler for the Save to File or Save to Repository menu items.

        This function is the starting point for saving a model to a .vql file or repository.
        Only selected items in the base model are saved!

        :return: None
        :rtype: None
        """
        logger.info(f"Saving file or repository in {show_mode(save_mode)} mode.")
        current_mode = self.get_mode()
        if not current_mode & BASE_LOADED:
            message_to_user("No repository loaded yet", parent=self)
            return

        if save_mode & FILE:
            file = self.ask_file_save()
            if file:
                self.run(self.save_model_to_file(file))
                logger.info(f"{file} saved.")
        elif save_mode & REPO:
            folder = self.ask_repository_save()
            if folder:
                self.run(self.save_model_to_repository(folder))
                logger.info(f"{folder} saved.")

    def on_reset(self):
        """Event handler to reset everything.

        This function actually restarts the whole application in a new process.
        Also the recent files and repositories are reset.

        :return: None
        :rtype: None
        """
        logger.info('Application restart.')
        settings = QSettings(COMPANY, APPLICATION_NAME)
        settings.clear()

        app_path = self._root / 'vql_manager.py'
        try:
            subprocess.Popen([sys.executable, str(app_path)])
        except OSError as exception:
            error_message_box('Restart Error', 'ERROR: could not restart application:', str(exception), parent=self)
        else:
            qApp.quit()

    def on_selection_clicked(self, item: Union[Chapter, CodeItem], *_):
        """Event handler for changes of the selection (check boxes) in the all_chapters_treeview (VqlModel).

        :param item: The item that changed in the all_chapters_treeview
        :type item: QTreeWidgetItem
        :param _: not used
        :return: None
        :rtype: None
        """
        self.last_clicked_class_type = item.class_type

    def on_selection_changed(self, item: Union[Chapter, CodeItem], *_):
        """Event handler for changes of the selection (check boxes) in the all_chapters_treeview (VqlModel).

        :param item: The item that changed in the all_chapters_treeview
        :type item: QTreeWidgetItem
        :param _: not used
        :return: None
        :rtype: None
        """
        def sel(_item: Union[Chapter, CodeItem])->bool:
            """
            if an item is selected
            :param _item: the item
            :return:
            """
            return False if _item.checkState(0) == UNCHECKED else True

        logger.debug('Item clicked on Selection Pane: ' + item.text(0))
        mode = self.get_mode()

        if mode & GUI_SELECT:
            if self.last_clicked_class_type == CodeItem:
                if item.class_type == CodeItem:
                    if not sel(item):
                        if any([sel(dependee) for dependee in item.dependees]):
                            message_to_user('This item has other items that are dependent on it.', parent=self)

        elif mode & GUI_COMPARE:
            if self.last_clicked_class_type == CodeItem:
                if item.class_type == CodeItem:
                    if sel(item):
                        if not item.compare_code:
                            item.compare_code = item.code
                            items = {code_item.object_name for code_item in item.dependencies}
                            dependencies_not_met = [item for item in items if not item.compare_code or not sel(item)]
                            if any(dependencies_not_met):
                                msg = 'This item has dependencies not met. '
                                message_to_user(msg + 'Check these: ' + '; '.join(dependencies_not_met), parent=self)
                else:
                    if item.class_type == CodeItem:
                        dependees_orphaned = [sel(dependee) for dependee in item.compare_dependees]
                        if any(dependees_orphaned):
                            msg = 'This item has other items that are dependent on it. '
                            message_to_user(msg + 'Check these: ' + '; '.join(dependees_orphaned), parent=self)

        self.all_chapters_treeview.changed = True
        self.update_timer.start(100)

    def on_click_item_selected(self, item: QTreeWidgetItem, col: int):
        """Event handler for looking up code in the View Pane (code item clicked).

        :param item: The CodeItem clicked on the Selection Tree
        :type item: QTreeWidgetItem
        :param col: The column --always zero, we only use 1 column in tree widgets
        :type col: int
        :return: None
        :rtype: None
        """

        if item:
            item_data = item.data(col, Qt.UserRole)
            if item_data['class_type'] == CodeItem:
                logger.debug('CodeItem clicked on View Pane: ' + item.text(0))
                cache = dict()
                cache['object_name'] = item_data['object_name']
                cache['code'] = item_data['code']
                cache['compare_code'] = item_data['compare_code']
                self.code_text_edit_cache = cache
                self.show_code_text()
            else:
                self.code_text_edit_cache = None

    def on_about_vql_manager(self):
        """Event handler for the click on the About menu item in the help menu.

        :return: None
        :rtype: None
        """
        QMessageBox.about(self, 'About ' + self.windowTitle(), about_text)

    def on_about_qt(self):
        """Event handler for the click on the About Qt menu item in the help menu.

        It uses the boilerplate Qt about box
        :return: None
        :rtype: None
        """
        QMessageBox.aboutQt(self, self.windowTitle())

    @staticmethod
    def format_source_code(object_name: str, raw_code: str, code_type: int)->str:
        """Creates html for the code edit widget to view the source code.

        :param object_name: Name of the CodeItem
        :type object_name: str
        :param raw_code: the raw code string
        :type raw_code: str
        :param code_type: and indicator what code is formatted either ORIGINAL_CODE or COMPARE_CODE or DIFF_CODE
        :return: the constructed html
        :rtype: str
        """
        if not raw_code:
            return ''

        html = ''
        if code_type & (ORIGINAL_CODE | COMPARE_CODE):
            code = raw_code.replace('\n', '<br />')
            code = code.replace('    ', ' &nbsp; &nbsp; &nbsp; &nbsp; ')

            for word in get_reserved_words():
                code = code.replace(' ' + word + ' ', ' <strong>' + word + '</strong> ')  # rude method here
            code = code.replace('<br />', '<br />\n')

            body = '<p style="color:' + white + '">' + code + '</p>'
            body = body.replace(object_name, '<font color="' + red + '">' + object_name + '</font>')
            html = doc_template(object_name, body)

        elif code_type & DIFF_CODE:
            html = doc_template(object_name, raw_code)
        return html

    def on_switch_view(self):
        """Event handler for the click on the menu item to switch between VQL view or Denodo view.

        :return: None
        :rtype: None
        """

        if self._mode & BASE_LOADED:
            if self.denodo_folder_structure_action.isChecked():
                if self.all_chapters_treeview.change_view(self._mode | DENODO_VIEW):
                    self.denodo_folder_structure_action.setText('Switch to VQL View')
                    logger.debug('Switching to Denodo View')
                else:
                    message_to_user('Denodo view not possible. Missing folders in the code.', parent=self)
                    self.denodo_folder_structure_action.setChecked(False)
                    logger.debug('Switch to Denodo View aborted')
            else:
                logger.debug('Switching to VQL View')
                self.denodo_folder_structure_action.setText('Switch to DENODO View')
                self.all_chapters_treeview.change_view(self._mode | VQL_VIEW)
            self.update_tree_widgets()

    # dialogs for opening and saving

    def ask_file_open(self)->Union[Path, None]:
        """Asks user which file to open to via a dialog.

        :return: filepath
        :rtype: Path
        """
        logger.info('Asking file to open.')
        dialog = QFileDialog(self)
        dialog.setAcceptMode(dialog.AcceptOpen)
        dialog.setDefaultSuffix('vql')
        dialog.setWindowTitle("Select single VQL file")
        dialog.setFileMode(QFileDialog.ExistingFile)
        dialog.setViewMode(QFileDialog.Detail)

        open_path = str(self.working_folder if self.working_folder else Path.cwd())

        filename, _ = dialog.getOpenFileName(self, "Save File", open_path,
                                             "Denodo Scripts (*.vql);;Text files (*.txt);;All files (*)",
                                             options=QFileDialog.DontResolveSymlinks)
        if not filename:
            return None

        filename = Path(str(filename))

        if not filename.exists():
            message_to_user("File does not exist", parent=self)
            return None

        if not filename.suffix == '.vql':
            message_to_user("This file has the wrong extension", parent=self)
            return None

        logger.info('Got: ' + str(filename))
        return filename

    def ask_repository_open(self)->Union[Path, None]:
        """Asks user which repository (folder) to open via a dialog.

        :return: the folder path
        :rtype: Path
        """
        logger.info('Asking repository to open.')
        open_path = str(self.working_folder if self.working_folder else Path.cwd())

        dialog = QFileDialog(self)
        dialog.setAcceptMode(dialog.AcceptOpen)
        dialog.setWindowTitle("Select Folder")
        dialog.setViewMode(QFileDialog.List)
        dialog.setOption(QFileDialog.ShowDirsOnly, True)
        folder = dialog.getExistingDirectory(self, "Open Directory", open_path)

        if not folder:
            return None
        folder = Path(str(folder))
        if not folder.is_dir():
            message_to_user("No folder found", parent=self)
            return None
        logger.info('Got:' + str(folder))
        return folder

    def ask_repository_save(self)->Union[Path, None]:
        """Asks user which folder to save to via a dialog.

        If the folder exists, then asks if overwrite is allowed.

        :return: Folder to store the repository
        :rtype: Path
        """
        logger.info('Asking repository to save.')
        open_path = str(self.working_folder if self.working_folder else Path.cwd())
        dialog = QFileDialog(self)
        dialog.setAcceptMode(dialog.AcceptSave)
        dialog.setFileMode(QFileDialog.Directory)
        folder = dialog.getExistingDirectory(self, "Save to Repository", open_path)

        if not folder:
            return None
        folder = Path(str(folder))

        if not folder.is_dir():
            try:
                folder.mkdir(parents=True)
                return folder
            except OSError as error:
                error_message_box('Error', 'Error creating folder', str(error), parent=self)
                return None

        if any([item_path.exists() for item_path, _
                in self.all_chapters_treeview.get_selected_code_files(self.get_mode(), folder)]):
            if not self.ask_overwrite():
                return None
        logger.info('Got:' + str(folder))
        return folder

    def ask_file_save(self)->Union[Path, None]:
        """Asks which file to save to via a dialog.

        It also checks if the file may be overwritten

        :return: the file path of the file to be written
        :rtype: Path
        """
        logger.info('Asking file to save.')
        open_path = str(self.working_folder if self.working_folder else Path.cwd())
        dialog = QFileDialog(self)
        dialog.setAcceptMode(dialog.AcceptSave)
        dialog.setDefaultSuffix('vql')
        dialog.setFileMode(QFileDialog.AnyFile)
        filename, _ = dialog.getSaveFileName(self, "Save File", open_path,
                                             "Denodo Scripts (*.vql);;Text files (*.txt);;All files (*)")

        if not filename:
            return None  # not cancel pressed
        filename = Path(str(filename))
        filename = filename if filename.suffix else filename.with_suffix('.vql')

        if filename.is_file():
            if not self.ask_overwrite():
                return None
            else:
                filename.unlink()
        logger.info('Got:' + str(filename))
        return filename

    # General purpose dialogs
    def ask_overwrite(self)->bool:
        """General Messagebox to warn/ask for files to be overwritten.

        :return: Boolean if allowed
        :rtype: bool
        """
        msg = QMessageBox(self)
        msg.setWindowTitle("Warning")
        msg.setIcon(QMessageBox.Question)
        msg.setText("<strong>Overwrite File(s)?<strong>")
        msg.setInformativeText("Do you want to overwrite current file(s)?")
        msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        msg.setDefaultButton(QMessageBox.No)
        if msg.exec() == QMessageBox.Yes:
            return True
        else:
            return False

    def ask_drop_changes(self)->bool:
        """General Messagebox to warn/ask if made changes can be dropped.

        :return: Boolean if allowed
        :rtype: bool
        """
        if not self.all_chapters_treeview.changed:
            return True

        msg = QMessageBox(self)
        msg.setWindowTitle("Warning")
        msg.setIcon(QMessageBox.Question)
        msg.setText("<strong>Drop the changes?<strong>")
        msg.setInformativeText("You are opening another repository,"
                               " that will discard any changes you made?"
                               "Click OK to proceed, and drop the changes.")
        msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        msg.setDefaultButton(QMessageBox.Cancel)
        if msg.exec() == QMessageBox.Ok:
            return True
        else:
            return False

    async def read_file(self, file: Path)->str:
        """General function to read in a file

        :param file: The path to the file
        :type file: Path
        :return: The contents of the file as string
        :rtype: str
        """
        logger.debug('Reading: ' + str(file))
        content = None
        try:
            with file.open() as f:
                content = f.read()
        except (OSError, IOError) as error:
            msg = "An error occurred during reading of file: "
            error_message_box("Error", msg + str(file), str(error), parent=self)
        if content:
            logger.debug(f"{str(file)} with {len(content)} characters read.")
        return content

    async def write_file(self, file: Path, content: str)->bool:
        """General function to write a file to disk

        :param file: the path where the file should be written to
        :type file: Path
        :param content: The content to be written as string
        :type content: str
        :return: Boolean on success
        :rtype: bool
        """
        logger.debug('Saving: ' + str(file))
        if file.is_file():
            try:
                file.unlink()
            except (OSError, IOError) as error:
                msg = 'An error occurred during removal of file : '
                error_message_box("Error", msg + str(file), str(error), parent=self)
                self.statusBar.showMessage("Save error")
                return False

        try:
            with file.open(mode='x') as f:
                written = f.write(content)
                logger.debug(f"Saved {written} characters to {str(file)}")
                return True
        except (OSError, IOError) as error:
            msg = "An error occurred during writing of file: "
            error_message_box("Error", msg + str(file), str(error), parent=self)
            return False

    # Saving and loading models

    async def load_model_from_file(self, file: Path, new_mode: int):
        """Loads a single .vql file into the VqlModel instance.

        :param file: path of the file to bew loaded in
        :type file: Path
        :param new_mode: either BASE_FILE or COMP_FILE
        :type new_mode: int
        :return: None
        :rtype: None
        """
        logger.debug(f"Loading model from file in {show_mode(new_mode)} mode")
        self.statusBar.showMessage("Loading model from file.")
        QApplication.setOverrideCursor(Qt.WaitCursor)
        tree = self.all_chapters_treeview
        content = await self.read_file(file)
        current_mode = self.get_mode()

        if content:
            tree.blockSignals(True)
            await tree.parse(content, new_mode)
            self.update_tree_widgets()
            tree.blockSignals(False)
        self.statusBar.showMessage("Ready")

        if new_mode & BASE_FILE:
            self.base_repository_file = file
            new_mode |= BASE_LOADED
        elif new_mode & COMP_FILE:
            self.compare_repository_file = file

            current_base_mode = current_mode & (BASE_REPO | BASE_FILE)
            new_mode |= current_base_mode | COMP_LOADED | BASE_LOADED | COMP_FILE

        self.switch_to_mode(new_mode)
        self.update_tree_widgets()
        self.working_folder = file.resolve().parent
        self.add_to_recent_files(file, FILE)
        QApplication.restoreOverrideCursor()
        logger.debug(f"Loading model from file finished.")

    async def load_model_from_repository(self, folder: Path, new_mode: int):
        """Loads a repository folder structure into the VqlModel instance.

        :param folder: the folder containing the repository
        :type folder: Path
        :param new_mode: flag indication BASE_REPO or COMP_REPO
        :return: None
        :rtype: None
        """
        logger.debug(f"Loading model from repository in {show_mode(new_mode)} mode")

        self.statusBar.showMessage("Loading model")
        QApplication.setOverrideCursor(Qt.WaitCursor)

        existing_folders = {sub_folder for sub_folder in folder.iterdir()}
        possible_folders = {folder / sub_folder for sub_folder in CHAPTER_NAMES}
        matching_folders = existing_folders & possible_folders
        if not matching_folders:
            QApplication.setOverrideCursor(Qt.WaitCursor)
            message = "No repository found. Did not find any matching sub folders."
            message_to_user(message, parent=self)
            self.statusBar.showMessage(message)
            return

        msg = 'Make sure your repository is not corrupt.'
        part_files = [folder / sub_folder / LOG_FILE_NAME
                      for sub_folder in CHAPTER_NAMES if folder / sub_folder in matching_folders]
        non_existing_part_files = [str(part_file) for part_file in part_files if not part_file.is_file()]
        existing_part_files = [part_file for part_file in part_files if part_file.is_file()]
        if non_existing_part_files:
            missing = ', '.join(non_existing_part_files)
            message_to_user(f"{LOG_FILE_NAME} file(s): {missing} not found. {msg}", parent=self)

        all_code_files = list()

        for part_file in existing_part_files:
            file_content = await self.read_file(part_file)
            code_files = [Path(code_file) for code_file in file_content.split('\n')]
            non_existing_code_files = [str(code_file) for code_file in code_files if not code_file.is_file()]
            if non_existing_code_files:
                missing = ', '.join(non_existing_code_files)
                message_to_user(f"Code file(s): {missing} not found. {msg}", parent=self)
            existing_code_files = [(str(code_file.parent.name), code_file)
                                   for code_file in code_files if code_file.is_file()]
            all_code_files.extend(existing_code_files)

        tree = self.all_chapters_treeview
        content = PROP_QUOTE
        for chapter in tree.chapters:
            content += chapter.header
            files = [file for chapter_name, file in all_code_files if chapter_name == chapter.name]
            for file in files:
                content += await self.read_file(file)

        current_mode = self.get_mode()

        if content:
            tree.blockSignals(True)
            await tree.parse(content, new_mode)
            self.update_tree_widgets()
            tree.blockSignals(False)
        else:
            self.statusBar.showMessage("Load Failed")
            QApplication.restoreOverrideCursor()
            return

        if new_mode & BASE_REPO:
            self.base_repository_folder = folder
            new_mode |= BASE_LOADED
        elif new_mode & COMP_REPO:
            self.compare_repository_folder = folder
            current_base_mode = current_mode & (BASE_REPO | BASE_FILE)
            new_mode |= current_base_mode | COMP_LOADED | BASE_LOADED | COMP_REPO

        self.switch_to_mode(new_mode)
        self.working_folder = folder
        self.update_tree_widgets()
        self.add_to_recent_files(folder, REPO)
        QApplication.restoreOverrideCursor()
        self.statusBar.showMessage("Model Loaded")
        logger.debug(f"Repository loaded with new mode {show_mode(self._mode)}")

    async def save_model_to_file(self, file: Path)->bool:
        """Saves the single .vql file.

        :param file: the file!
        :type file: Path
        :return: boolean on success
        :rtype: bool
        """

        logger.debug(f"Saving model to file in {file} in mode: {show_mode(self.get_mode())}")
        tree = self.all_chapters_treeview

        self.statusBar.showMessage("Saving")
        tree.blockSignals(True)
        content = tree.get_code_as_file(self.get_mode(), selected=True)
        tree.blockSignals(False)
        if content:
            if await self.write_file(file, content):
                self.statusBar.showMessage("Ready")
                logger.debug("Saved OK")
                return True
            else:
                self.statusBar.showMessage("Save error")
                logger.debug("Not Saved")
                return False

    async def save_model_to_repository(self, folder: Path)->bool:
        """Saves the model selection to a repository.

        The files are written to chapter_folders
        :param folder: The folder to write the repository
        :type folder: Path
        :return: boolean on success
        :rtype bool
        """
        logger.debug(f"Saving model to repository in folder {folder} in mode: {show_mode(self.get_mode())}")
        self.statusBar.showMessage("Saving")
        if not folder:
            self.statusBar.showMessage("Save Error")
            return False

        tree = self.all_chapters_treeview
        tree.blockSignals(True)

        for part_log_filepath, part_log_content in tree.get_part_logs(folder):

            if not part_log_content:
                self.statusBar.showMessage("Save Error")
                return False

            if not part_log_filepath:
                self.statusBar.showMessage("Save Error")
                return False

            sub_folder = part_log_filepath.parent
            if not sub_folder.is_dir():
                try:
                    logger.debug("Creating Directory.")
                    sub_folder.mkdir(parents=True)
                except (OSError, IOError) as error:
                    self.statusBar.showMessage("Save Error")
                    error_message_box("Error", "An error occurred during creation of the folders in : "
                                      + sub_folder, str(error), parent=self)
                    return False

            if not await self.write_file(part_log_filepath, part_log_content):
                self.statusBar.showMessage("Save Error")
                logger.debug("Saved not OK")
                return False

        for file_path, content in tree.get_selected_code_files(self.get_mode(), folder):
            if not content:
                self.statusBar.showMessage("Save Error")
                logger.debug("Saved not OK")
                return False
            if not file_path:
                self.statusBar.showMessage("Save Error")
                logger.debug("Saved not OK")
                return False
            if not await self.write_file(file_path, content):
                self.statusBar.showMessage("Save Error")
                logger.debug("Saved not OK")
                return False

        tree.blockSignals(False)
        self.statusBar.showMessage("Ready")
        logger.debug("Saved OK")
        return True

    def add_to_recent_files(self, file_path: Path, mode: int):
        """Function adds a file path to the OS storage of recent files.

        :param file_path: The path to add
        :type file_path: Path
        :param mode: selector flag either REPO or FILE
        :type mode: int
        :return: None
        :rtype: None
        """
        logger.debug(f"Adding {file_path} to recent file list in {show_mode(mode)} mode")
        settings = QSettings(COMPANY, APPLICATION_NAME)

        if not settings:
            logger.debug("No resent file settings found.")
            return

        if mode & FILE:
            settings_list = RECENT_FILES
        elif mode & REPO:
            settings_list = RECENT_REPOSITORIES
        else:
            return

        paths = settings.value(settings_list, type=list)
        file = str(file_path)
        if file in paths:
            paths.remove(file)
        paths = [file] + paths
        if len(paths) > MAX_RECENT_FILES:
            paths = paths[:MAX_RECENT_FILES]
        settings.setValue(settings_list, paths)

        self.update_recent_file_actions()
        logger.debug("Path added to recent files or folders.")

    def show_code_text(self):
        """Shows the code of the clicked CodeItem in the Code edit widget.

        :return: None
        :rtype: None
        """

        if self.code_text_edit_cache:
            # convenience names
            item_data = self.code_text_edit_cache
            selector = self.code_show_selector
            put_text = self.code_text_edit.setHtml
            set_title = self.code_text_edit_label.setText
            object_name = item_data['object_name']
            html_code = ''
            if self._mode & GUI_SELECT:
                html_code = self.format_source_code(object_name, item_data['code'], selector)
                set_title("Code: " + object_name)
            elif self._mode & GUI_COMPARE:

                if selector & ORIGINAL_CODE:
                    html_code = self.format_source_code(object_name, item_data['code'], selector)
                    set_title("Original Code: " + object_name)
                elif selector & COMPARE_CODE:
                    html_code = self.format_source_code(object_name, item_data['compare_code'], selector)
                    set_title("New Code: " + object_name)
                elif selector & DIFF_CODE:
                    difference = CodeItem.get_diff(item_data['code'], item_data['compare_code'])
                    html_code = self.format_source_code(object_name, difference, selector)
                    set_title("Differences : " + object_name)
            put_text(html_code)

    def update_tree_widgets(self):
        """Builds/sets new content of the selected_treeview

        Like a screen update.
        Used after the selection in the all_chapters_treeview is changed
        This function copies the selected items and leaves out the chapters that are empty
        The updates are timed because when big changes are made (when whole chapters are unselected)
        the function should not redraw the screen to often.

        :return: None
        :rtype: None
        """
        logger.debug('Update_tree_widgets')
        # stop the update timer
        self.update_timer.stop()
        # store former "blocked" indicator
        blocked = self.all_chapters_treeview.signalsBlocked()

        # block signals while updating
        self.all_chapters_treeview.blockSignals(True)

        # convenience pointer names
        tree_sel = self.selected_treeview
        root_sel = tree_sel.invisibleRootItem()

        tree_all = self.all_chapters_treeview
        root_all = tree_all.invisibleRootItem()
        tree_sel.clear()
        tree_all.pack()
        root_sel.addChildren(root_all.clone().takeChildren())
        VqlModel.unpack(tree_sel)

        # # itemIterator traverses over every node
        self.remove_checkboxes(tree_sel)
        self.all_chapters_treeview.blockSignals(blocked)

    @staticmethod
    def remove_checkboxes(tree: QTreeWidget):
        """

        :param tree:
        :return:
        """
        item_iterator = QTreeWidgetItemIterator(tree)
        while item_iterator.value():
            item = item_iterator.value()
            item.setData(0, Qt.CheckStateRole, QVariant())
            item_iterator += 1


def main():
    """Main entry point for the application

    Boilerplate python code to start and end the application and allows it to be in a module or library
    :return:
    """
    logger.info("Entering main")
    global app

    if version_info < (3, 6):
        message_to_user('You need at least Python version 3.6 to run this application.')
        return

    app = QApplication(argv)
    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())
    window = VQLManagerWindow()
    window.show()
    exit(app.exec())


if __name__ == '__main__':
    main()
